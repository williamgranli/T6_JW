

\documentclass{sig-alternate}
\usepackage{blindtext}
\usepackage[english]{babel}

%
\usepackage{array}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{booktabs} 


%Used for \textsubscript
\usepackage{fixltx2e}

\usepackage{url}

\usepackage{placeins}

\begin{document}


\conferenceinfo{14th IWPSE} {'15 Bergamo, Italy}
\CopyrightYear{2015}

\crdata{1-23456-78-9/01/23}


\title{The Driving Forces of API Evolution}


\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
John Burchell\\
       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{john.a.burchell@gmail.com}
% 2nd. author
\alignauthor
William Granli\\
       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{william.granli@gmail.com}
%\and
% 3rd. author
%\alignauthor Imed Hammouda\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
% 4th 
%\alignauthor Eric Knauss\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
}

\maketitle

\begin{abstract}
%Motivation
Evolving an Application Programming Interface (API) is a precipitous activity, as modifications to them can significantly impact their users. The increasing use of APIs means that software development organisations must take an empirical and scientific approach to the way they manage the evolution of their APIs. 
%Problem
If no attempt at analysing or quantifying the evolution of an API is made, there will be a diminished understanding of the evolution, and possible improvements to the maintenance strategy will be difficult to identify. We believe that long-standing software evolution theories can provide additional insight to the field of APIs, and can be of great use to companies maintaining APIs. 
%Method
In this case study, we conduct a qualitative investigation to understand what drives the evolution of an industry company's existing API, by examining two versions of the API code. The changes were analysed based on two software evolution theories, and the extent to which we could reverse engineer the change decisions was determined by interviewing the architect of the API. 
%Results
The results of this analysis show that the largest driving force of API evolution is the desire for new functionality. Our findings which show that changes happen sporadically, rather than continuously, invalidate a law of software evolution in the context of APIs. We also found that it is possible to reverse engineer change decisions and in doing so, identified that the feedback loop of an API is the most important area of improvement. 
\end{abstract}

\category{D.2.7}{Software Engineering}{Distribution, Maintenance, Enhancement}[Restructuring, reverse engineering, and re-engineering]
\keywords{API Design, Software Evolution, Software Maintenance}


\newpage
\section{Introduction} \label{introduction}
%API Design background
As the software industry and the open-source movement continue to grow, the number of public Application Programming Interfaces (APIs) is steadily increasing. APIs can improve the development speed \cite{stylos2006comparing}, contribute to higher quality software \cite{stylos2006comparing} and increase the reusability of software \cite{afonso2012evaluating}. There is a consensus in that modifications to APIs could negatively impact the users of the API \cite{google_talk, henning2007api, mcdonnell2013empirical, robbes2012developers}. The main reason for this is that it requires the API users to update the application code, thus causing a disruption in the application's software ecosystem \cite{messerschmitt2005software}. 
%Software Evolution background
In the discipline of software evolution, such updates to software are studied from an evolutionary standpoint. Software can be updated for different reasons and these motives can be grouped into corrective, adaptive, perfective and preventive changes \cite{lientz1980software}. 

%Purpose, general
Modifications to deployed APIs may negatively impact its users. It is therefore important to investigate why these changes occur. Understanding the motives behind the changes could help API architects to prevent potential future changes to their APIs. Before industry can safely include such information in their feedback loop, we must critically assess to what degree we can reverse engineer such motives. 
%Purpose, case company
Identifying the types of changes that occur when an API evolves will improve communication and discussions regarding maintenance and evolution tasks for the case company. This improved communication could provide a common language that developers, users and management can use to discuss potential evolution of the APIs. Understanding the evolution theories could further assist understanding of how change will occur and how to plan for it. Lastly, by keeping a history of changes to an API over time, trends can be identified which could help with future API design.

%Gap in Literature
Previous studies have investigated programming language APIs, libraries or frameworks focusing on causes and affects of modifications to APIs \cite{dig2005role, hou2011exploring, shi2011empirical}. However, to the best of our knowledge, no studies have been performed on embedded platform APIs from a software evolution perspective. Our study will fill this gap by analysing an embedded platform API by using software evolution theories and by classifying the types of changes that occur.

%Goal of the study
The goal of the study was twofold. Firstly, the aim was to explore what are the driving forces of API evolution and secondly, to validate the results' level of correctness by comparing our findings with the case company's explanation of the changes. With this information, we could determine to what extent these change decisions can be reverse engineered. 

%Structure ofpaper
The sections following the Introduction are structured as follows: In Section \ref{background}, we present the background and previously published work that is related to our study and introduce the case company and their API. A description of our methodology is introduced in Section \ref{methodology}. In Section \ref{results}, the results of our study are presented and in Section \ref{discussion}, we discuss the implications of our work. In Section \ref{conclusion} summarise the study and give suggestions for future work that builds on our research. 

\section{Background} \label{background}
This section will introduce the fields of API design, software evolution and it will provide a review of studies that are related to our study. The subsequent section will introduce the case company with a description of the API used in this study.  

\subsection{API Design} \label{api_design}
API design is notoriously difficult as a myriad of design and performance decisions must be taken into consideration when creating APIs \cite{afonso2012evaluating, bloch2008effective, stylos2006comparing}. Examples of such design decisions include how to structure an object's constructor parameters or if the API should display errors at compilation or at runtime \cite{stylos2006comparing}. More trivial design problems, such as assigning names to API features or correctly naming user-defined types, can have a significant impact on the usability of an API \cite{shi2011empirical}. When facing such design challenges, the following four factors are important to consider: a) The API must be understandable through good documentation, b) the API must not be overly abstract, c) the API must be reusable and d) the API must be easy to learn \cite{shi2011empirical}. One of the most important qualities in an API is that the intent of the API must be clear to the user \cite{shi2011empirical, stylos2006comparing}. The design decisions reached during development of an API will affect the overall usability of the API. Measuring such an effect can be done by investigating the twelve cognitive dimensions that are impacted by interactions between the API and its users \cite{clarke2004measuring}. 

\subsection{Software Evolution} \label{software_evolution}
%%Types of maintenance and types of maintenance
Software evolution is a field that studies the application of software maintenance activities, changes in software processes and the resulting, evolved versions of the software. The concept of software maintenance has existed since the 1960s when it was first introduced to the software development community \cite{lientz1980software}. A set of four categories describing different kinds of software maintenance \cite{lientz1980software} became the basis upon which twelve new types were developed \cite{chapin2001types}. The twelve types of software evolution and software maintenance, as seen in Table \ref{table:expl_types}, describe a software evolution activity that relates to one of three particular areas; the code, the software and the customer-experienced functionality. 

\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Type}                              & \textbf{Explanation}    \\ \midrule
              Corrective    & Corrections of functionality                   \\ \hline
              Reductive     & Reductions of functionality                    \\ \hline
              Adaptive      & Inclusion of new Technology                    \\ \hline
              Performance   & Improvements to Performance                    \\ \hline
              Preventive    & Improvements to future maintainability         \\ \hline
              Groomative    & Improvements to maintainability                \\ \hline
              Updative      & Updates to documentation                       \\ \hline
              Reformative   & Changes to documentation                       \\ \hline
              Evaluative    & Inspection activities                          \\ \hline
              Consultive    & Consultations activities                       \\ \hline
              Training      & Training activities                            \\ 

              \bottomrule

       \end{tabular}
       \caption{Types of Software Evolution  \cite{chapin2001types}}
       \label{table:expl_types}
\end{table}

\begin{table}
       \centering
       \begin{tabular}[ht]{p{3in}}
       \toprule
              \begin{enumerate}
              \item \textbf{Continuing Change}  \newline
              E-Type systems must be continually adapted else they become progressively less satisfactory.                     
              \item \textbf{Increasing Complexity} \newline
              As an E-Type system evolves its complexity increases unless work is done to maintain or reduce it.                  
              \item \textbf{Self Regulation} \newline
              E-Type system evolution process is self regulating with distribution of product and process measures close to normal.                     
              \item \textbf{Conservation of Organisational Stability} \newline
              The average effective global activity rate in an evolving E-Type system is invariant over product lifetime.                     
              \item \textbf{Conservation of Familiarity} \newline
              As an E-type system evolves all associated with it, developers, sales personnel, users, for example, must maintain mastery of its content and behaviour to achieve satisfactory evolution. Excessive growth diminishes that mastery. Hence the average incremental growth remains invariant as the system evolves.                     
              \item \textbf{Continuing Growth} \newline
              The functional content of E-Type systems must be continually increased to maintain user satisfaction over their lifetime.                
              \item \textbf{Declining Quality} \newline
              The quality of E-Type systems will appear to be declining unless they are rigorously maintained and adapted to operational environment changes.                     
              \item \textbf{Feedback System} \newline
              E-Type evolution process constitute multi-level, multi-loop, multi-agent feedback systems and must be treated as such to achieve significant improvement over any reasonable base.

              \end{enumerate} \\
              \bottomrule
       \end{tabular}
       \caption{Lehman's Laws of Software Evolution \cite{lehman90sview}}
       \label{table:expl_laws}
\end{table}
Software evolution theory suggests that changes to software must obey one of eight laws \cite{lehman90sview}, known as Lehman's laws. The laws are presented in Table \ref{table:expl_laws}. The laws are said to only apply to E-type systems, which are programs that solve problems or address applications in the real world. Two other types of systems are also identified; S-type systems and P-type systems. S-type systems are programs which are exactly derivable from a specification. An example of such a program is one which finds the lowest common denominator for two integers. An example of a P-type system is a chess program. These types of programs can be derived from a specification, but the rules of the program have to be abstracted. In the case of a chess program, the possible moves have to be abstracted, since exactly specifying all the possible permutations would be virtually impossible. Based on this, we consider APIs to be E-type systems, since they are heavily dependant on the environment and its changes. It is therefore not possible to create an exact specification of any non-trivial API. 





\subsection{API Evolution} \label{related_work}
The analysis of APIs in the context of software evolution has primarily focused on APIs that are part of large programming languages, such as Java \cite{hou2011exploring, shi2011empirical} and Smalltalk \cite{robbes2012developers}. Attempts to uncover the intents of the changes made in the Java libraries, AWT and Swing, have also been undertaken \cite{hou2011exploring}, leading to suggestions that the use of a strong architecture is vital for ensuring the successful evolution of an API \cite{hou2011exploring}.


Investigations of three frameworks and one library indicated that 80\% of refactoring changes to APIs negatively affected existing applications \cite{dig2005role}. The changes, sometimes referred to as ripple effects \cite{robbes2012developers} indicate that negative effects of changes can propagate throughout a software ecosystem. It was found that 14\% of non-trivial API deprecations caused errors in at least one project, with the worst case of 79 projects being affected \cite{robbes2012developers}.

 


\subsection{Case Company Description} \label{case_company_description}
The case company of this study will from here on be referred to as \textit{company A}. Company A operates in the domain of video surveillance. The company's headquarters is located in Lund, Sweden, with offices in 49 countries worldwide. Company A is the global market leader in the markets of network cameras and video encoders. They develop embedded software for security cameras. The cameras are designed to be accessible through APIs that are developed and maintained by the company. 

The API analysed in this study is written in the programming language C and has been deployed for several years. It was recently updated from v1.4 to version 2.0, which is the current active version. The changes between these two versions is what has been analysed in this study. Between the release of version 1.0 and 1.4, no functionality was added, as it only added additional build options for other hardware platforms. Prior to v1.4 being released, updates were only made to include additional built options and did not include any additional functionality. The API is used by company partners, which are other companies which develop applications for the cameras. These applications are, in turn, used by the end-users of the cameras. The API is developed for a wide range of camera types that offer different functionality and are used for different purposes. 



\section{Methodology} \label{methodology}


%Intro and summary
This study has been conducted using the case study methodology \cite{runeson2009guidelines}. Our research can be classified as an embedded case study \cite{yin2013case}, since both the API code and API documentation have been used as units of analysis. The reason the selected methodology was used is that it is essential to study the phenomenon of API change in its natural context. The applicability of case studies in such scenarios is supported by existing literature \cite{benbasat1987case, robson2002real, runeson2009guidelines, yin2013case}. An alternative approach that was considered was design research, but if a prototype API was to be used instead of one which is tried and tested in an industry setting, the study would lack real-life context \cite{runeson2009guidelines}. An additional motivation for why the case study approach was used is that there is little existing research conducted in the area of drivers of API change and that input from the industry is vital to the success of the research. 

The study was conducted in two major phases \cite{andersson2007spiral}. The aim of the first phase was to generate hypotheses and to formulate clear research questions. This was achieved by using a data-driven approach to analysing the code and documentation. The second phase included analysis of the interviews, during which we aimed to confirm the hypotheses that were formulated in the first phase. Both phases were performed iteratively. This created the opportunity to improve the data analysis as the study progressed, as well as, allowing us to adapt to possible changes in direction, due to the hypothesis generating approach of the first phase. 
\begin{table}
       \centering
       \begin{tabular}[ht]{p{3in}}
              \toprule

              \textbf{Phase 1: Data Collection}
              
              \begin{enumerate}
				\item Inspect v1.4
				\item Inspect v2.0
				\item Identify changes between versions
				\item Conduct interview
				\item Structure gathered data
				\item Formulate hypotheses
              \end{enumerate} \\ 


              
              \textbf{Phase 2: Data Analysis} 
              
              \begin{enumerate}
              \item Code changes
              \item Group changes
              \item Categorise groups 
              \item Identify and formulate trends
              \item Analyse based on types \cite{chapin2001types}
              \item Analyse based on laws \cite{lehman90sview}
              \item Validate hypotheses
              \end{enumerate} \\
              
              \bottomrule
       \end{tabular}
       \caption{Methodology Overview}
       \label{table:meth_steps}
\end{table} 

The process used for examining the code and documentation was inspired by grounded theory analysis \cite{seaman1999qualitative}, as it is recommended for hypothesis generating studies \cite{runeson2009guidelines, seaman1999qualitative}. The exploratory analysis lead us to formulate the following research questions.



\begin{description}
\item[\textbf{RQ1}] What drives API evolution?
\item[\textbf{RQ2}] To what extent can we reverse engineer API change decisions?
\end{description}



\subsection{Data Collection} \label{data_collection}  
%Intro to code inspection
The data were collected primarily through inspections of the source code and of accompanying documentation. The source code was comprised of the two API versions previously mentioned. Each version of the API had its own respective documentation, including example code, a library description and a basic development manual. 

%How the initial inspection was performed
The API code was inspected sequentially, starting with v1.4. Both versions of the API underwent the same type of inspection. This involved extracting method signatures, enums, structs, typedefs and macros, which were subsequently stored in spreadsheets. The extraction involved a lot of manual work, but Git's \cite{git} diff command was used to identify changes in files which exist in both versions. After a change was identified in the code, a description of the corresponding change in the documentation was added to the spreadsheet. The module and file in which the change was identified was then logged together with an ID and a description of the change. The data collection from code and documentation was performed independently by both researchers to reduce the risk of human errors affecting the results. If the data collected by each researcher differed, the cause of the discrepancy was investigated and resolved. 

%Purpose of the interview
After the initial source code and documentation inspection, an interview was conducted. The main purpose of the interview was to validate our findings from the code inspection with the API architect. The interview also served the purpose of providing additional insight into what drove the evolution of the API, by complementing what was found from the inspections. The final reason for interviewing the API architect was to gather information about the API users and how their decisions, needs and requirements have affected the development of the API. 

%Structure of the interview
The interview was conducted using a semi-structured approach \cite{robson2002real}. Structure to the interview was provided by organising it around the software evolution theories \cite{chapin2001types, lehman90sview}. Investigative and open-ended questions related to each type and law were asked to provide a basis for comparison between the answers and our initial analysis. The interviewee was encouraged to speak freely, even if it required a change in direction or topic. This was encouraged in order to fulfil our exploratory goal of the study. 




\subsection{Data Analysis} \label{data_analysis}

%Codes
To analyse the data, each change identified in the spreadsheet was coded based on which module the change occurred in and two other characteristics: a) if the change added, removed or modified functionality, and b) if the change was a cosmetic change or not.
%Concepts
Grouping the codes by module allowed us to form general concepts of change. However, changes that affected multiple modules were classified on their own.
%Categories
These concepts were then grouped into categories based on common patterns between the concepts.
%Theory
These categories were then used to identify the most notable trends in the evolution of the API. These trends were later used as a basis for discussion during the interview.

%RQ1
The trends identified previously were then classified with help of the decision tree used for classifying the types of software evolution and software maintenance \cite{chapin2001types}. Each of the previously identified trends were given a main type of change and, if appropriate, a secondary type. Main types of change identify the primary motive for a trend, whereas the secondary types are additional motivations for a trend. For example, if an identified trend was the re-implementation of an old module that included new functionality and made use of a new interface, it would be classified as mainly enhancive and secondarily groomative. In addition to this, we analysed the trends based on Lehman's Laws, to determine if they applied to the changes made to the API. This information, as well as the results of the interview, were then used as the basis for answering \textbf{RQ1}.

%RQ2
To allow us to answer \textbf{RQ2}, we compared our analysis and interpretation of the trends identified prior, against what was expressed by the API architect, during the interview. Success was determined by comparing the inter-rater reliability, by calculating Cohen's kappa \cite{cohen1968weighted} for the gathered data. 





\subsection{Validity Threats} \label{validity_threats} 
In this section we discuss possible threats to construct validity, internal validity, external validity and reliability \cite{runeson2009guidelines}.

\smallskip \noindent
\textbf{Construct validity  } Since our study is largely based on existing theories \cite{chapin2001types, lehman90sview}, the validity of it directly correlates to the validity of the theories and the applicability of them. 

\smallskip \noindent
\textbf{Internal validity  } Limitations related to internal validity have been acknowledged by analysing the code and documentation jointly. This has contributed to triangulating the results and discovering possible inconsistencies. Further triangulation of the results was performed by interviewing the API architect. Business-related factors might have had an impact on the evolution of the API, and these were not closely investigated. This was not in the scope of the study and would best be investigated in a study complementary to ours. The study revealed that the API users were significant to the evolution of the API. Since API users were not interviewed, it might be an affecting factor which was left unexplored. 

\smallskip \noindent
\textbf{External validity  } The results of our study should be highly generalisable to similar studies conducted on any type of APIs, since the evolution of the API has largely been driven by software-related factors. Our study can especially be compared to similar studies conducted on platform or embedded APIs. Further comparability to our study is offered through how the results are structured around established software evolution theories. 

\smallskip \noindent
\textbf{Reliability  } Due to restricted access to company A's source code, we were not able to include versions prior to v1.4 in our analysis. This means that the evolution of the API was studied during a rather short period of its lifetime. It was also not possible to analyse the implementation of the API, something which might have contributed to more accurate predictions of the motives behind the changes. We consider these factors to be the remaining threats to reliability. Reliability has been increased by conducting the study according to an accredited guide to case studies \cite{runeson2009guidelines}. In addition to that, strategies from additional well-established papers \cite{andersson2007spiral, robson2002real, seaman1999qualitative} have been used to increase the trustworthiness of the data gathering and data analysis. 



\section{Results} \label{results} 
%%Write new

%%Small intro to this section. Mention that : In total, thirteen unique changes were found.
This section will present the results of our study and is structured around the research questions. Each section begins with a summary of the results and a subsequent in depth description of the findings.

In total, thirteen unique changes were identified when analysing the source code, the majority of which were additions of functionality of the API. Such additions include added functionality to allow mechanical and digital control of the camera, to utilise additional storage devices, to allow serial connectivity and to allow audio analysis on the cameras. Changes that were pure additions the API were not attributed with any secondary types of change.

Many of the changes were deprecations that were later re-implemented as new modules. Changes of these kinds were grouped into a single type instead of two. Such examples include the deprecation and re-implementation of an event system, dynamic web page generation and configuration utilities. Changes of this kind often had an accompanying secondary type of change.

The remainder of the changes were defined as general trends. These changes were not changes to individual parts of the API, but were instead broader changes. Such examples include a shift towards using interfaces to access features, a different error-handling approach and the inclusion of additional 3\textsuperscript{rd} party libraries. Typically, these general trends also have a secondary type of change attributed to them.



\subsection{The Driving Forces of API Evolution} \label{results_rq1}

%Types intro
The results show that certain types of change are more prevalent than others, these results are shown in Table \ref{table:type_counts}. Analysis of the results showed that enhancive changes were the primary types of change that drive API evolution and that they act as a catalyst for many of the other changes in the API. Updative changes were found to be consequences of enhancive changes, rather than being drivers of evolution. Supporting the users of the API through the combination of preventive and groomative types of change, together formed another strong driver of API evolution. Reductive and adaptive changes, while important, did not strongly drive the evolution of the API. No evidence was found for corrective or performance types of change. Similarly, there was no evidence found for evaluative, consultive or training activities.    

\begin{table}
       \centering
       \begin{tabular}[ht]{l|c|c}
              \toprule

              \textbf{Type}        & \textbf{Main Types}       &\textbf{Secondary Types}   \\ \midrule
              Enhancive            & 7                         & -                         \\ \hline
              Corrective           & -                         & -                         \\ \hline
              Reductive            & 1                         & -                         \\ \hline
              Adaptive             & 1                         & -                         \\ \hline
              Performance          & -                         & -                         \\ \hline
              Preventive           & 2                         & -                         \\ \hline
              Groomative           & -                         & 5                         \\ \hline
              Updative             & 1                         & 1                         \\ \hline
              Reformative          & 1                         & 1                         \\ \hline
              Evaluative           & -                         & -                         \\ \hline
              Consultive           & -                         & -                         \\ \hline
              Training             & -                         & -                         \\ 

              \bottomrule

       \end{tabular}
       \caption{Identified Types of Change}
       \label{table:type_counts}
\end{table}

%Lehman Intro
Our analysis of the results related to \textbf{RQ1} showed that seven out of the eight laws \cite{lehman90sview} do apply to APIs. A summary of our findings can be seen in Table \ref{table:lehman}. The evidence found for the laws of Continuing Change, Self Regulation, Conservation of Familiarity, Continuing Growth and Feedback System mainly relate to enhancive changes that add functionality to the API. It was also found that the laws of Increasing Complexity and Declining Quality do apply, but that the changes which support these laws usually had a secondary intent related to complexity or quality. The only law which was found not to apply to the API analysed in this study was the law of Conservation of Organisational Stability. Our results rather show the opposite, that the work rate is variant. 

%Lehman Table
\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Law}                              & \textbf{Applicability}    \\ \midrule
              Continuing Change                         & True                      \\ \hline
              Increasing Complexity                     & True                     \\ \hline
              Self Regulation                           & True                      \\ \hline
              Conservation of Organisational Stability  & False                     \\ \hline
              Conservation of Familiarity               & True                      \\ \hline
              Continuing Growth                         & True                      \\ \hline
              Declining Quality                         & True                     \\ \hline
              Feedback System                           & True                      \\ 

              \bottomrule

       \end{tabular}
       \caption{The applicability of Lehman's laws}
       \label{table:lehman}
\end{table}

Following this section, we will discuss the results related to each type of change category, discussing the results for each of them with examples from the changes identified between the two versions of the API. Subsequently, each of Lehman's laws will be discussed and our results will be presented showing if the laws apply to APIs or not.





\subsubsection{Types of Change}

\smallskip \noindent
\textbf{Enhancive  }
%Define how we identified the change type
Additions or re-implementations of functionality are defined to be enhancive changes. In addition to this, we have included deprecations that have then been re-implemented to also be enhancive.
%Some Data and little explanation
Seven of the identified changes were given the type of enhancive. The majority of which were additions of new functionality to the API. Two examples of added functionality are the addition of camera movement module and an audio analysis module. One example of a deprecation that was re-implemented is the event system.
%Conclusion
Given that over half of the changes were identified to be enhancive, we conclude that the APIs evolution primary type of change was enhancive. 

\smallskip \noindent
\textbf{Corrective  }
%Define what kinds of changes these are
Corrective changes are identified as types of change that fix broken functionality.
%Data and explanation
No corrective changes were identified between v1.4 and version 2.0. There are two main reasons that we did not find any changes of this type. Firstly, the majority of changes were additions or re-implementations of functionality. This meant that most of the existing code was either removed, replaced or deprecated, resulting in little to no obvious fixes. Secondly, we only had access to the public facing API and not the implementation itself. We therefore could not inspect the inner workings of the functionality that has remained between versions to determine if any corrective change took place.
%Conclusion
We therefore conclude that the evolution of the API was not driven by corrective changes.

\smallskip \noindent
\textbf{Reductive  }
%Definition
Reductive changes are defined as changes that remove or reduce functionality. This is distinctive from a deprecation as reductive types of change remove functionality completely.
%Data & Explanation
Only a single reductive type of change was identified. This reductive change removed functionality that provided the ability to buffer individual images for closer analysis by a user. Given that it is more common to refactor APIs and not remove functionality \cite{dig2005role, xing2006refactoring}. It was revealed during the interview that the functionality was removed because the company A no longer wished to support this feature. 
%Conclusion
As this was the only reductive change found, we conclude that the evolution of the API was not primarily driven by reductive changes.

\smallskip \noindent
\textbf{Adaptive  }
%Introduction and definition
Adaptive changes are defined to be changes which involve changes to technology or resources used. 
%Data and examples
A single change was identified as being adaptive; the inclusion of new 3\textsuperscript{rd} party libraries. Libraries were added for audio and data communication. The pre-existing low-level library was incorporated into the API.
%Conclusion 
We therefore conclude that the evolution of the API has not been primarily driven by adaptive changes.

\smallskip \noindent
\textbf{Performance  }
%Define
Performance changes are defined to be types of change that intentionally alter system performance.
%Data and examples
No evidence of performance-driven changes were identified in the API.
%Conclusion
This therefore leads us to conclude that API evolution is not driven by performance changes.

\smallskip \noindent
\textbf{Preventive  }
%Define
Preventive changes are defined to be changes that attempt to avoid future maintenance. This should not be confused with changes that attempt to make the current state of the system more maintainable.
%Data and examples
Two changes were identified to be preventive types of change. A new error handling system was one of these changes. Version 2.0 of the API added specific error handling modules and functions which replaced the pre-existing error-handling in v1.4 of the API. The redesign of the system to make use of interfaces was also classified as a preventive change. Using interfaces to access modules helps to make them more maintainable and more easily extensible.
%Concusion
Preventive types of change appear to drive the evolution of an API more strongly than other types of change. This could be due to the fact that as the API grows, the need for higher maintenance also increase, a fact that also seems to be supported by Lehman's laws.

\smallskip \noindent
\textbf{Groomative  }
%Define
Groomative changes are defined to be changes that aim to immediately make the code more maintainable.
%Data and examples
While none of the change identified were primarily groomative changes, three of them were secondarily classified as being groomative. This indicates that the groomative nature of a change is often a positive affect of other types of change. The move towards using interfaces can be seen as an example of this. While the primary motive of change was to make the API more maintainable in the future, making the API more maintainable immediately was also a reason for the change.
%Conclusion
While not a primary factor for any of the changes, groomative types of change should still be viewed as important for API evolution.

\smallskip \noindent
\textbf{Updative  }
%Define
Updative changes are defined to be changes to documentation of a system.
%Data and example
A single change was determined to be updative; updating the API documentation to include the new functionality of v2.0. The updates included a new API specification, deprecation list and the inclusion of the new features and libraries.
%Conclusion
Updative changes have very little impact on the functionality of the API yet they are still important changes for the usability of the API \cite{shi2011empirical}. Changes to the API cause the need for updative changes to its documentation, without them, the usability of the API could suffer. We therefore conclude that the evolution of an API is not driven by updative changes.

\smallskip \noindent
\textbf{Reformative  }
%Define
Reformative changes are defined to be changes that update the documentation to the stakeholders needs.
%Data and Example
One reformative change was identified between v1.4 and version 2.0; a redesign of the existing example programs. The aim of this change was to update the examples to illustrate the new functionality in the API, showing how the modules interact and at the same time, presenting a standard for how to use the API.
%Conclusion
We therefore conclude that reformative changes, while important for the usability of the API, do not drive the evolution of the API.

\smallskip \noindent
\textbf{Evaluative, Consultive and Training  }
%Define
Evaluative, consultive and training are all types of activities, rather than changes that a system can undergo. Evaluative activities are defined as activities such as auditing or evaluating the software. Similarly, consultive activities involve consultations with customers about the software. Finally, training activities involve training for customers and users of the software.
%Data and example
None of the aforementioned activities occurred as part of the APIs evolution as these activities do not play a role in API evolution. This is supported by the fact none of the activities were identified for the changes.
%Conclusion
We can therefore conclude that these change types are not important for API evolution.


\subsubsection{Lehman's Laws} 

\smallskip \noindent
\textbf{Continuing Change  } 
Company A described that including new functional content was one of the top priorities for the release of version 2.0. This is supported by the characteristic of the changes identified in this study. Four of the thirteen changes were additions of new modules, and additional functionality was also added to re-implemented modules. It was also mentioned that the API users had previously requested more frequent updates to the API, despite the drawbacks this could cause. One of the main reasons for continuously adapting the API is also to control the way API users use the API. Prior to version 2.0 being released, a number of API users used workarounds to implement applications which contained functionality which was not yet offered from the API. These applications were fully functional, but there existed no standard method of implementation. We therefore conclude that the law of Continuing Change holds for APIs. 

\smallskip \noindent
\textbf{Increasing Complexity  } \label{sec:law2} 
A majority of the changes introduced in version 2.0 aimed to improve the structure and the way that the API was used. Many of these changes were related to the same design choices, which enforced a certain implementation style on the whole API. One example of this is the change to the interfaces which set a standard for the whole API. During the interview it was also concluded that consistency and following certain standards is an important factor to consider when designing APIs. It was also made clear that a contributing factor for changing certain parts of the API was to bring it into line with the new interface design. The interviewee mentioned that one way of achieving this was to follow guidelines or design best practices, but that company A currently did not make use of these. Although the importance of reducing the complexity was stated, it was made clear during the interview that one module was not updated between the versions, even though it did not follow the new standards of version 2.0. In conclusion, we establish that the law of Increasing Complexity is true for APIs. 

\smallskip \noindent
\textbf{Self Regulation  } \label{sec:law3} 
The release of v1.4 did not include any changes related to the API interface. Version 1.0 through to 1.4 strictly added support for additional build target platforms. When comparing the changes introduced in version 2.0 to the ones in previous versions, it is clear that the growth of the API has gradually increased. During the interview it was also mentioned that the future plans for the API did not include any major changes and that only a few minor changes were planned in the near future. The future updates to the API will also be made incrementally and there will not be a big bang update similar to that of version 2.0. This supports that the law of Self Regulation applies to APIs, assuming that version 2.0 can be considered to be the peak of the normal distribution curve of the APIs growth. 

\smallskip \noindent
\textbf{Conservation of Organisational Stability  } 
The changes to the API have been made very sporadically, where only two new versions have been released since the deployment of version 1.0. As mentioned in Section \ref{sec:law3}, the changes introduced in v1.4 did not involve any changes to the existing API functions. Consequently, the only significant update to the API was made in the transition to version 2.0. The internal development of the API has also been made sporadically and there have been periods where the API has not been actively developed. This suggests that the law of Conservation of Organisational Stability does not apply to APIs. 

\smallskip \noindent
\textbf{Conservation of Familiarity  } 
The documentation that is included with the API was rigorously updated with the introduction of version 2.0. All functionality which was added or modified in version 2.0 was updated accordingly in the documentation. The same pattern can be seen for the example code, which went through major changes as a result of the changes to the API code. Company A's intent to control the way that their API is used also suggests that the knowledge of how to use the API is of importance, since if the API is used in too many different ways, it will be more difficult for company A to have relevant documentation and example code. It was also expressed during the interview that further transparency in how the API should be used could be achieved. One example mentioned of how this could be achieved is by improving the expressiveness regarding which API functions are supported on which hardware types. These facts support that the law of Conservation of Familiarity is true for APIs. 

\smallskip \noindent
\textbf{Continuing Growth  } 
Large parts of the changes between the versions were strictly additions of new functional content. 4 new modules were added and significant additions of new functionality were added to the modules which were re-designed from v1.4. The interviewee also made it clear that increasing the functionality was one of the main goals with the 2.0 update. This also ties in with the ambition of controlling the way that the API is used, as mentioned previously. It was also mentioned that company A had received feedback from the API users that more frequent updates to the functional content was desirable, even though this may require them to update their application code. We therefore conclude that the law of continuing growth applies to APIs. 

\smallskip \noindent
\textbf{Declining Quality  } 
The interviews established that a groomative motive was not the primary reason for implementing any change. The changes to the example code and the documentation, as well as the re-designed modules are examples of these, where the main motive behind the change was to either prevent unwanted usage or to increase the functional content. These changes did, however, also increase the quality and were a substantial part of the update. Our analysis also shows that changes related to quality are bound to happen, as other types of changes often incorporate quality related aspects. We therefore settle that the law of Declining Quality applies to APIs. 

\smallskip \noindent
\textbf{Feedback System  } 
One of the future goals of improvement of company A is to better include the API users and end-users of the applications in their feedback loop. Currently, only the API users are included in this feedback loop and the API architect expressed the desire to also include the end-users. The reasoning for this was to increase the quality, and to be able to deliver content which is useful for the users and which leads to good applications being developed. Prior to version 2.0 being released, an example of how the API users were included in the feedback loop was when they implemented functionality related to sound, despite the fact there was no interface for this.  The experiences of this API user, were later considered when developing the axsound module. One benefit of having a more structured feedback loop, would be that the API developers would have greater awareness of potential errors in the implementation of the API. Another ambition which was mentioned, was to bring scientific theories and best practices from research into consideration when developing the API. This would aim to complement the current strategy which is largely based around the expertise and experiences of the API architects. Based on these factors and clearly expressed ambitions, we conclude that the law of Feedback System is true for APIs. 



\subsection{Reverse Engineering API Change Decisions}
After cross-examining our initial analysis with the interviewee's responses, we found that 85\% of our main type predictions matched the actual motive of the change and that 85\% of our secondary type predictions were correct. The kappa value \cite{cohen1968weighted} for the predictions was 0.812, which shows that there is a high level of agreement between the predictions and the change decisions. In Table \ref{table:reverse_engineering}, a detailed view of each prediction juxtaposed against the actual change decision can be found for both the main and secondary types.  

The changes related to functionality being added, modified (deprecated) or removed were predicted with a 100\% accuracy. These changes were deemed the most significant by the interviewee, and it was expressed during the interview that the these types of changes were the main driving factor of the development of the new version. On the contrary, three out of five changes which were unrelated to functionality were correctly predicted. The two changes which were not predicted correctly were inaccurate because the main type was confused with the secondary type. This shows that, although the prediction was incorrect, the general reasoning was correct. The changes which had no secondary type were all predicted correctly, which further shows that changes with several types can be diffuse. 



\begin{table}
       \centering
       \begin{tabular}[ht]{  c | c !{\vrule width 1.5pt} c|c} 
              \toprule

              \multicolumn{2}{c !{\vrule width 1.5pt} }{\textbf{Main}}       & \multicolumn{2}{c}{\textbf{Secondary}}        \\ \hline

              \textbf{Prediction}         & \textbf{Actual}            & \textbf{Prediction}       & \textbf{Actual}         \\ \Xhline{2\arrayrulewidth}
              Enhancive                   & Enhancive                 & N/A                       & N/A                \\ \hline
              Enhancive                   & Enhancive                 & N/A                       & N/A                \\ \hline
              Enhancive                   & Enhancive                 & N/A                       & N/A                \\ \hline
              Enhancive                   & Enhancive                 & N/A                       & N/A                \\ \hline
              Enhancive                   & Enhancive                 & Groomative                & Groomative         \\ \hline
              Enhancive                   & Enhancive                 & Groomative                & Groomative         \\ \hline
              Enhancive                   & Enhancive                 & Groomative                & Groomative         \\ \hline
              Reductive                   & Reductive                 & N/A                       & N/A                \\ \hline
              Adaptive                    & Adaptive                  & N/A                       & N/A                \\ \hline
              Preventive                  & Preventive                & Groomative                & Groomative         \\ \hline 
              Updative                    & Updative                  & Reformative               & Reformative        \\ \hline
              Updative                    & Reformative               & Reformative               & Updative           \\ \hline
              Groomative                  & Preventive                & Preventive                & Groomative         \\

              \bottomrule
       \end{tabular}
       \caption{Categorisation of Changes }
       \label{table:reverse_engineering}
\end{table}


\section{Discussion} \label{discussion}

\noindent
RQ1: \textbf{What drives API evolution?}
\smallskip

Our results show that the major driving force for change in APIs is the call for increased functionality. The classification of the types of software evolution and software maintenance showed that enhancive changes which either aimed to add modules or new functionality to existing modules were the most common. We also think that it is interesting to note that a majority of the changes which did not affect functionality, such as the updative changes, were spurred because of previous changes that were related to functionality. Following this line of thought, the desire for new functionality can be seen as a catalyst that allows new change to occur. The view of considering functionality to be a major driver for change is supported by the analysis with Lehman's laws. In the law of Continuing Change, Lehman concludes that ``an E-type system must be continually adapted or it becomes progressively less satisfactory". The results of our work supports this view, as the changes did not only add functionality, but it was also found that the application developers most major concern were updates to functionality. 

In relation to this, previous work has identified that refactorings make up a substantial part of the changes APIs undergo \cite{dig2005role, dig2006apis, henkel2005catchup, xing2006refactoring}. These results are not in line with ours, since our results show that groomative changes are uncommon and that changes related to quality are not primary drivers of change, rather, they are ripple-effects of changes to functionality \cite{robbes2012developers}.

The results also showed that usability was the second-most important driver of API evolution. The classified updative, groomative and reformative changes all affected the maintainability and usability of the API and involved activities that have been found to improve the usability and maintainability of an API \cite{afonso2012evaluating, clarke2004measuring, piccioni2013empirical, shi2011empirical}. The interviewee discussed how company A wanted to aid developers creating applications by improving the interfaces that the developers are using. This improvement to the interfaces would better communicate the design and intentions to the developer. Improving the documentation of the API was also important for v2.0, as were improvements to the example code. These updates were intended to aid developers and create a set of standards that should be followed when creating applications. These changes correspond with three of Lehman's laws: Conservation of Familiarity, Declining Quality and Feedback Loop.  

Our results found that seven out of eight of Lehman's laws do apply to API evolution. The law of Conservation of Organisational Stability was found not to apply, since changes to APIs are unfavourable due to the potential disruption the applications using the API could face. This inertia to change in API evolution is supported by other research, which also conclude that the negative effect that changes to APIs may have is a major factor to be considered \cite{google_talk, henning2007api, mcdonnell2013empirical, robbes2012developers}. 

Based on our results, we form the conclusion that the desire for functionality and the reluctance of changing are two opposing forces that cause updates to APIs to be infrequent. In the evolution of APIs, the negative effects of changes are greater than in other types of systems, which is the main cause for the law of Conservation of Organisational Stability not applying to APIs. This occurring has been considered by Lehman, as he noted that ``the laws are not immutable, since they arise from the habits and practices of humans" \cite{lehman1980programs}. The underlying reason for this is that the laws are influenced by conscious thought processes, based on human understanding \cite{lehman1980understanding}, which in the case of APIs is the conscious decision to limit updates as much as possible. 

\smallskip
\noindent
RQ2: \textbf{To what extent can we reverse engineer API change decisions?}
\smallskip

We conclude that we were able to reverse engineer the change decisions to a large extent. This is clear from the results, which showed that 85\% of the changes were reverse engineered correctly. The kappa value of 0.812 further supports this. We interpret that the significance of this result suggests that reverse engineering of change decisions can be done in situations where a perfect result is not required. In cases where a near-perfect result is enough, we do, however, believe that reverse engineering change decisions is worthwhile. This line of thought is supported by our results, which, in summary, show that we are able to reverse engineer the most major trends with very high accuracy, but that certain nuances of the changes can be misinterpreted. 



\subsection{Implications for Research} 
The implications of our findings should encourage research to further study APIs by relating them to existing software evolution theories. Considering that we were able to successfully reverse engineer the changes made to the API in this study, it opens up possibilities to base future research on, for example, the types of software evolution and software maintenance. Since the kappa analysis showed that there was a high level of agreement between our predictions and the actual motives to the change, it shows that the types of software evolution and software maintenance could even be used as a base for a large-scale quantitative analysis to map the types of changes made to APIs. 

By analysing the API based on Lehman's laws, we were able to find that the law of Conservation of Organisational Stability did not apply to the API examined in this study. Our results suggest that the opposite of what the law suggests, in its current form, is more applicable for APIs. Since only a single API was studied, we cannot safely refute the law or propose a new formulation of it. Research should therefore be wary of assuming that this law is true for APIs.



\subsection{Implications for Company A}
The changes introduced to the API are mainly based on the expertise and experiences of the API architects at company A. There has not been a scientific approach to maintaining the system and the knowledge from research has not directly affected the way that the API's evolution has been managed. With our work, we hope to provide further insight into how the API is maintained. Our analysis of the API based on Lehman's laws should further assure that company A is moving the evolution of the API in the right direction. Our research proposes a dilemma for company A in how to tackle challenges related to the law of Conservation of Organisational Stability. Determining if the benefits of continuously and frequently updating the API outweigh the side-effects that these updates could have on the application developers, is something that company A will need to consider.

One way of finding the solution to this problem would be by including the application developers in the feedback loop. Since the application developers are on the receiving end of the changes, we believe that their needs have to be assessed before the problem can be solved. With our study we identified both that the law of Feedback System is of great importance to company A and that it is one of the key areas of API development that company A wishes to improve. One challenge of the challenges posed by software evolution is that the activities carried out are often intangible and non-objective \cite{chapin2001types, lientz1980software}. Based on this, we propose that our study which has granulated the activities is used as a basis for communicating the current stage of the evolution of their API. We hope that this classification can be used in its current form, to help quantify the activities and to provide an overview of them. We also hope that the approach we used can be used to predict which types of activities should be emphasised in the future evolution of the API. With our study we have also demonstrated that the classification of changes is achievable, which, in turn, should encourage company A to adopt this method of classifying change.






\section{Conclusion} \label{conclusion}
With this study, we conclude that studying API evolution with help of existing theories, provides a new and structured approach to the field of API evolution. Our study shows that functionality is the largest driving force of change in the evolution of APIs. It also concludes that APIs do not change invariantly, and that maintenance of an API rather is infrequent and sporadic. This finding lead us to invalidate Lehman's law of Conservation of Organisational Stability in the context of APIs. With this study we have also identified the importance of having a structured feedback loop when maintaining an API. We have also provided company A with a foundation for facilitating such a change. 

To build on our study, we propose that a study on the eco-system's role in the evolution of APIs is conducted. We believe that this area could be a major source of improvement for API evolution. Exploring the benefits of including application developers and additional entities of the eco-system in the feedback loop, is a good starting point for company A. In such a study, we would suggest that the types of software evolution and software maintenance \cite{chapin2001types} could be used as a mean of facilitating discussion between the entities. It could also be possible to study the effect that changes to APIs have on the application code, in such a study. 

To further investigate what drives API evolution, we believe that API evolution has to be studied from a business point of view. We therefore suggest that a similar study is conducted, but with the goal of analysing the change of an API based on business motives. Positioning a study around business motives would help identifying the changes before they are formulated into technical changes, and it would provide a new and fresh angle to the field of API evolution. 

Lastly, based on our successful attempt to reverse engineer the changes made to this API, we suggest that a quantitative study is conducted to investigate the distribution of the types of software evolution and software maintenance and the applicability of Lehman's laws on a large scale. 










\section{Acknowledgements}
We would like to thank company A for allowing us to conduct this study in cooperation with them. We would also like to thank associate professor Imed Hammouda for assisting us with this research. 


\bibliographystyle{abbrv}
\bibliography{bib} 






\end{document}










