

\documentclass{sig-alternate}
\usepackage{blindtext}
\usepackage[english]{babel}

%
\usepackage{array}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{booktabs} 


%Used for \textsubscript
\usepackage{fixltx2e}



\begin{document}


\conferenceinfo{14th IWPSE} {'15 Bergamo, Italy}
\CopyrightYear{2015}

\crdata{1-23456-78-9/01/23}


\title{Exploring the Types and Driving Forces Behind Modifications to APIs From a Software Evolution Perspective}


\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
John Burchell\\
%       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{john.a.burchell@gmail.com}
% 2nd. author
\alignauthor
William Granli\\
%       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{william.granli@gmail.com}
%\and
% 3rd. author
%\alignauthor Imed Hammouda\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
% 4th 
%\alignauthor Eric Knauss\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
}

\maketitle

\begin{abstract}


\textbf{Background  } %Give a feeling of the need of this study, answer why Axis needs what is in the Objective (+Context)
The driving forces of modifications to APIs have been investigated before, however, platform APIs are, until now, unexplored. Previous studies have not considered APIs from the perspective of well-established software evolution theories. 

\smallskip \noindent
\textbf{Objective  } %Done
In this study, we explore how companies actively evolve their APIs and 'how APIs evolve from a passive point of view'. We also aim to evaluate to what extent we are able to reverse engineer these evolutionary change decisions. The goal is to study these factors by evaluating them against existing software evolution theories. 

\smallskip \noindent
\textbf{Method  } %Done
This case study was conducted by analysing the changes between two versions of a platform API and its documentation. The results were analysed from a qualitative and investigative perspective, and were then reviewed and validated with the architects of the API. 

\smallskip \noindent
\textbf{Results  } %Done
We identified thirteen major changes which were introduced in the new version of the API. We concluded that the dominant driving force of the API evolution is demand for new functionality and that change decisions, to a large extent, are reverse engineerable. We also found that long-established software evolution laws were largely applicable to APIs. 

\smallskip \noindent
\textbf{Conclusion  }
This study has provided valuable insight into the evolution of platform APIs. The qualitative analysis can help other companies to improve their API maintenance process. The successful attempt to reverse engineer the change decisions should encourage similar studies to be conducted. The investigation of Lehman's laws show that APIs cannot be generalised and be compared to any type of system. 



\end{abstract}

\category{D.2.7}{Software Engineering}{Distribution, Maintenance, Enhancement}[Restructuring, reverse engineering, and re-engineering]
\category{K.6.3}{Computing Milieux}{Software Management}[Software Maintenance]

\terms{Theory, Design or Verification/Documentation maybe?}

\keywords{API Design, Software Evolution, Software Maintenance}



\section{Introduction} \label{introduction}
%API Design (and a little bit of ecosystems and a bit of problem statement)
As the software industry and the open-source movement continue to grow, the number of public APIs is steadily increasing. APIs can improve the development speed \cite{stylos2006comparing}, contribute to higher quality software \cite{stylos2006comparing} and increase the reusability of software \cite{afonso2012evaluating}. There is a consensus in that modifications to APIs could negatively impact the users of the API \cite{google_talk} \cite{mcdonnell2013empirical} \cite{robbes2012developers} \cite{henning2007api}. The main reason for this is that it requires the API users to update the application code, thus causing a disruption in the application's software ecosystem \cite{messerschmitt2005software}. Refactoring is the most common change that APIs undergo \cite{dig2005role} \cite{xing2006refactoring}. 
%Software Evolution 
In the discipline of software evolution, such updates to software are studied from an evolutionary standpoint. Software can be updated for different reasons and these motives can be grouped into corrective, adaptive, perfective and preventive changes \cite{lientz1980software}. 

%Gap in Literature
Studies that explore the intent behind API modifications exist \cite{hou2011exploring}. There are, however, no studies that attempt to map the motives behind changes to existing software evolution theories, such as the types of software evolution and software maintenance activities \cite{chapin2001types}. The area of programming language APIs is well-explored \cite{hou2011exploring} \cite{shi2011empirical}, but few studies that explore platform APIs exist \cite{robbes2012developers}. To the best of our knowledge, no studies that explore API evolution have until now been performed on embedded platform APIs. 

%switch places between ^ and v

%Purpose
Modifications to deployed APIs may negatively impact its users. It is therefore important to investigate why these changes occur. Understanding the motives behind the changes could help API designers to  prevent potential future changes to their APIs. Before the industry can safely include such information in their feedback loop, we must critically assess to what degree we can reverse engineer such motives. 

%Method %wrong tense %include RQs in here %include clear contribution (to johanna)
In order to achieve this, an exploratory case study will be undertaken to investigate the underlying motives behind changes to APIs. Empirical analysis of the changes between two major versions of an API will be undertaken, following which, an interview with the architects will be used to validate the findings of our analysis. 

%Can't find a place for this - it's repeated in the Purpose
%Reverse engineering design decisions is a challenging yet interesting problem. The better we can understand why changes occur and what problems they are trying to solve, the better we can design around these problems to avoid them cropping up in the future.


\subsection{Research Questions} \label{rqs}
\begin{description}
\item[\textbf{RQ1}] How do companies actively drive API evolution?
\item[\textbf{RQ1.1}] To what extent can we reverse engineer API change decisions?
\item[\textbf{RQ2}] How do APIs ``passively'' evolve?


\end{description}

%Structure of the paper
The sections following the Introduction are structured as follows: In Section \ref{existing_literature}, we present the background and previously published work that is related to our study. Section \ref{case_company_description} describes the case company and the API which was studied. A description of our methodology is introduced in Section \ref{methodology}. In Section \ref{results}, the results of our study are presented and in Section \ref{discussion}, we discuss the findings of our study. In Section \ref{conclusion} we propose the potential impact of our work and give suggestions for future work that builds on our research. 

\section{Background} \label{existing_literature}
This section will introduce the fields of API design and software evolution, and provide a review of studies that are directly related to our study. 


\subsection{API Design} \label{api_design}
API design is notoriously difficult, as a myriad of design and performance decisions must be taken into consideration when creating APIs \cite{afonso2012evaluating} \cite{bloch2008effective} \cite{stylos2006comparing}. Examples of such decisions include whether or not to make use of the factory pattern or if an API should display errors only at compilation or only at runtime \cite{stylos2006comparing}. More trivial design problems, such as assigning names to API features or correctly naming user defined types, can have a significant impact on the usability of an API \cite{shi2011empirical}. When facing such design challenges, the following four factors are important to consider: a) The API must be understandable through good documentation, b) the API must not be overly abstract, c) the API must be reusable and d) the API must be easy to learn \cite{shi2011empirical}. One of the most important qualities in an API is that the intent of the API must be clear to the user \cite{stylos2006comparing} \cite{shi2011empirical}. The design decisions reached during development of an API will affect the overall usability of the API. Measuring such an effect can be done by investigating the twelve cognitive dimensions that are impacted by interactions between the API and its users \cite{clarke2004measuring}. 


\subsection{Software Evolution} \label{software_evolution}
%%Categories of maintenance and types of maintenance
Software evolution is a field that studies the application of software maintenance activities, changes in software processes and the resulting, evolved versions of the software. The concept of software maintenance has existed since the 1960s when it was first introduced to the software development community \cite{lientz1980software}. A set of four categories describing software maintenance categories \cite{lientz1980software} became the basis upon which twelve new categories were created \cite{chapin2001types}. The twelve categories are: enhancive, corrective, reductive, adaptive, performance, preventive, groomative, updative, reformative, evaluative, consultive and training \cite{chapin2001types}. Each category describes a software maintenance activity that relates to one of three particular areas; the code, the software and the customer-experienced functionality \cite{chapin2001types}. It has been suggested that software maintenance is a part of software evolution and that the two terms are not interchangeable \cite{chapin2001types}.

%%Lehman's laws (!!!improve later)
Software evolution theory suggests that changes to software must obey one of eight laws \cite{lehman1980programs}. The laws, known as Lehman's laws, are: 1) Continuing Change, 2) Increasing Complexity, 3) Self Regulation, 4) Conservation of Organisational Stability, 5) Conservation of Familiarity, 6) Continuing Growth, 7) Declining Quality and 8) Feedback System \cite{lehman1980programs}. The laws are said to only apply to E-type systems, which are programs that are ``change prone" and that ``mechanise a human or societal activity" \cite{lehman1980programs}.     

\subsection{API Evolution} \label{related_work}
The analysis of APIs in the context of software evolution has primarily focused on APIs that are part of large programming languages, such as Java \cite{hou2011exploring} \cite{shi2011empirical} and Smalltalk \cite{robbes2012developers}. Attempts to uncover the intents behind the changes made in the AWT and Swing Java libraries have also been undertaken \cite{hou2011exploring}, leading to suggestions that the use of a strong architecture is vital for ensuring the successful evolution of an API \cite{hou2011exploring}.

Investigations of three frameworks and one library indicated that 80\% of refactoring changes to APIs negatively affected existing applications \cite{dig2005role}. The changes, sometimes referred to as ripple effects \cite{robbes2012developers} indicate that negative effects of changes can propagate throughout a software ecosystem. It was found that 14\% of non-trivial API deprecations caused errors in at least one project, with the worst case of 79 projects being affected \cite{robbes2012developers}.



%%Possibly add a paragraph here to 

\subsection{Case Company Description} \label{case_company_description}
The case company is a company operating in the domain of video surveillance. The company's headquarters are located in Lund, Sweden, with offices in 49 countries worldwide. The company is the global market leader in the markets of network cameras and video encoders. They develop embedded software for security cameras. The cameras are designed to be accessible through APIs that are developed and maintained by the company. 

The API analysed in this study is written in the programming language C and has been deployed for several years. It was recently updated from version 1.4 to version 2.0, which is the current active version. The changes between these two versions is what has been analysed in this study. Between the release of version 1.0 and 1.4, no functionality was added, as it only added additional build options for other hardware platforms. Prior to version 1.4 being released, updates were only made to include additional built options and did not include any additional functionality. The API is used by company partners, which are companies who develop applications for the cameras. These applications are, in turn, used by the end-users of the cameras. The API is developed for a wide range of camera types that offer different functionality and are used for different purposes. 

%The case company was selected using convenience sampling \cite{flyvbjerg2006five} and a maximum variation strategy was used \cite{benbasat1987case}. As such, the goal was to include as many companies as possible in this study.



\section{Methodology} \label{methodology}
%Intro and summary
This study has been conducted using the case study methodology \cite{runeson2009guidelines}. The goal of the study was twofold. Firstly, the aim was to empirically explore the motives behind changes to APIs and secondly, to validate the results' level of correctness by comparing our findings with the case company's explanation of their motives. Our research can be classified as an embedded case study \cite{yin2013case}, since both the API code and API documentation have been used as units of analysis. 

%Reasons for choosing case study
The reason the selected methodology was used is that it is essential to study the phenomenon of API change in its natural context. The applicability of case studies in such scenarios is supported by existing literature \cite{benbasat1987case} \cite{runeson2009guidelines} \cite{yin2013case} \cite{robson2002real}. An alternative approach that was considered was design research, but if a prototype API was to be used instead of one which is tried and tested in an industry setting, the study would lack real-life context \cite{runeson2009guidelines}. An additional motivation for why the case study approach was used is that there is little existing research conducted in the area of motives behind API change and that input from the industry is vital to the success of the research, especially to be able to answer \textbf{RQ1.1}. 


\subsection{Data Collection} \label{data_collection}  %Review 1 or 2 more times (John first)
%Intro to code inspection
The data were collected primarily through inspections of the source code and the analysis of accompanying documentation. The source code was comprised of the two API versions previously mentioned. Each version of the API had its own respective documentation, including example code, a library description and a basic development manual. 

%How the initial inspection was performed
The API code was inspected sequentially, starting with version 1.4. Both versions of the API underwent the same inspection. This involved extracting method signatures, enums, structs, typedefs and macros, which were subsequently stored in spreadsheets. The extraction involved a lot of manual work, but Git's \cite{git} diff command was used to identify changes in files which exist in both versions. After a change was identified in the code, a description of the corresponding change in the documentation was added to the spreadsheet. The module and file in which the change was identified was then logged together with an ID and a description of the change. The data collection from code and documentation was performed independently by both researchers, to reduce the risk of human errors affecting the results. If the data collected by each researcher differed, the cause of the discrepancy was investigated and resolved. 

%Purpose of the interview
After the initial source code inspection and preliminary analysis had been performed, an interview was conducted. The main purpose of the interview was to validate our findings from the code inspection with the API architect. The interview also served the purpose of providing additional insight into what drove the evolution of the API, by complementing what was found from the code inspection. The final reason for interviewing the API architect was to gather information about the API users and how their decisions, needs and requirements have affected the development of the API. 

%Structure of the interview
The interview was conducted using a semi-structured approach \cite{robson2002real}. Structure to the interview was provided by organising it around the software evolution theories \cite{chapin2001types} \cite{lehman1980programs}. Investigative and open-ended questions related to each category and law were asked to provide a basis for comparison between the answers and our initial analysis. The interviewee was encouraged to speak freely, even if it required a change in direction or topic. This was allowed in order to fulfil our exploratory goal of the study. 


\subsection{Data Analysis} \label{data_analysis}
%Intro and summary
The data analysis was conducted in two major phases \cite{andersson2007spiral}. During the first phase, a hypothesis generating approach \cite{seaman1999qualitative} was used to be able to fulfil the exploratory goal of the study. It was during this phase that the analysis of the API code and documentation was carried out. The second phase included analysis of the interviews, the goal of which was to confirm the hypotheses \cite{seaman1999qualitative} that were formulated in the first phase. Both phases were performed iteratively, together with the data collection. This created the opportunity to improve the process of analysis as the study progressed, as well as, allowing the study to adapt to possible changes in direction, due to the hypothesis generating approach of the first phase \cite{andersson2007spiral}. 

%Grounded Theory
The analysis of the code and documentation was performed using grounded theory analysis \cite{seaman1999qualitative}, as it is recommended for hypothesis generating studies \cite{runeson2009guidelines} \cite{seaman1999qualitative}.
%Codes
Each change identified in the spreadsheet was coded based on which module the change occurred in and two other characteristics: a) if the change added, removed or modified functionality, and b) if the change was a cosmetic change or not.
%Concepts
Grouping the codes by module allowed us to form general concepts of change. However, changes that affected the whole API were categorised on their own.
%Categories
These concepts were then grouped into categories based on common patterns between the concepts.
%Theory
These categories were then used to identify the most notable trends in the evolution of the API. These trends were later used as a basis for discussion during the interview.

%RQ1
The categories identified previously were then classified according to the software maintenance categories \cite{chapin2001types}. The process followed the decision tree used for classifying the types of software evolution and software maintenance \cite{chapin2001types}. Each of the previously identified categories were given a main category of maintenance and a secondary category, if appropriate. This material was then used as a basis for answering \textbf{RQ1}.

%Description of interview analysis
The results of the interview were analysed and categorised in the same way that our identified changes had been. Validation of our findings, by comparing our categorisation against the interviewee's categorisation, was performed at this point. 

%Lehman's - RQ2
The analysis of the trends and the changes, combined with information gathered during the interview, allowed us to answer \textbf{RQ2} by determining if Lehman's laws are applicable to the changes to the API \cite{lehman1980programs}.

%RQ1.1
The final stage of analysis was conducted once all the data had been analysed, which allowed us to answer \textbf{RQ1.1}. This was accomplished by comparing our analysis and interpretation of the change motives against the opinions expressed during the interview. Success was determined by the amount of correct interpretations made about the motives of the changes. Our ability to correctly predict the motives, compared to the designers' actual motives which were made clear during the interviews, served as the basis for answering \textbf{RQ1.1}.


\subsection{Validity Threats} \label{validity_threats} %Review 1 or 2 more times (John first)
In this section we discuss possible threats to construct validity, internal validity, external validity and reliability \cite{runeson2009guidelines}.

\smallskip \noindent
\textbf{Construct validity  } Threats to construct validity have largely been mitigated by structuring the results of the study around already established and accepted software evolution theories \cite{chapin2001types} \cite{lehman1980programs}. Due to restricted access to the company's source code, we were not able to include versions prior to version 1.4 in our analysis. This means that the evolution of the API was studied during a rather short period of its lifetime. It was also not possible to analyse the implementation of the API, something which might have contributed to more accurate predictions of the motives behind the changes. We consider these factors to be the remaining threats to construct validity. 

\smallskip \noindent
\textbf{Internal validity  } Limitations related to internal validity have been acknowledged by analysing the code and documentation jointly. This has contributed to triangulating the results and discovering possible inconsistencies. Further triangulation of the results was performed by interviewing the API architect. Business-related factors might have had an impact on the evolution of the API, and these were not closely investigated. This was not in the scope of the study and would best be investigated in a study complementary to ours. The study revealed that the API users were significant to the evolution of the API. Since API users were not interviewed, it might be an affecting factor which was left unexplored. 

\smallskip \noindent
\textbf{External validity  } The results of our study should be highly generalisable to similar studies conducted on any type of APIs, since the evolution of the API has largely been driven by software-related factors. Our study should be of special interest to researchers studying platform or embedded APIs. The fact that the results of the study are presented in a structured way, by relating them to existing software evolution theories, should further increase the generalisability of our study.

\smallskip \noindent
\textbf{Reliability  } Potential threats to the reliability of our study have, to a great extent, been reduced by conducting the study according to a well-reputed guide to case studies \cite{runeson2009guidelines}. In addition to that, strategies from additional well-established papers \cite{andersson2007spiral} \cite{seaman1999qualitative} \cite{robson2002real} have been used to increase the trustworthiness of the data gathering and data analysis. The analysis was based around well-defined theories that are cemented in academia, to further increase the reproducibility of the study. The semi-structured nature of the interview, might threaten the reproducibility; however, large parts of it were structured around existing theories. 


\section{Results} \label{results} %Reviewed by JW
This section will present the findings of our study. The results related to \textbf{RQ1} and \textbf{RQ1.1} are introduced in Section \ref{results_rq1}, and the results of \textbf{RQ2} are presented in Section \ref{results_rq2}

\newpage
\newpage
\subsection{RQ1 Results} \label{results_rq1} %Reviewed by JW
\noindent
RQ1: \textbf{How do companies actively drive API evolution?}

\noindent
RQ1.1: \textbf{To what extent can we reverse engineer API change decisions?}
\smallskip

Many changes were found between version 1.4 and version 2.0. The initial inspection revealed there to be many deprecations which were later re-implemented as new modules. We have group these changes into a single change instead of a deprecation and a re-implementation. In total, thirteen unique changes were found. These changes are shown in Table \ref{table:categories}.

The changes have been divided up into four specific categories, namely: \textit{new}, \textit{modified}, \textit{removed} and \textit{general trends}. The category \textit{new} concerns additions of modules, \textit{modified} concerns modifications to modules that existed in version 1.4 and \textit{removed} are changes where functionality was removed being deprecated or replaced by functionality. \textit{General trends} are broad changes that are mainly related to design. 

After cross-examining our results with the interviewee and their responses, we found that 78\% of our main category predictions matched the actual motive of the changes and that 78\% of our secondary categorisations matched the actual motives. 


\begin{table}
       \centering
       \begin{tabular}[ht]{c !{\vrule width 1.5pt} c|c !{\vrule width 1.5pt} c|c} 
              \toprule

              \multirow{2}{*}{\textbf{Change}}          & \multicolumn{2}{c !{\vrule width 1.5pt} }{\textbf{Main}}       & \multicolumn{2}{c}{\textbf{Sub}}        \\ \cline{2-5}

                                   & \textbf{P}                & \textbf{A}                & \textbf{P}                & \textbf{A}         \\ \Xhline{2\arrayrulewidth}
              axptz                & E                         & E                         & N/A                       & N/A                \\ \hline
              axaudio              & E                         & E                         & N/A                       & N/A                \\ \hline
              axstorage            & E                         & E                         & N/A                       & N/A                \\ \hline
              axserialport         & E                         & E                         & N/A                       & N/A                \\ \hline
              axevent              & E                         & E                         & G                         & G                  \\ \hline
              axhttp               & E                         & E                         & G                         & G                  \\ \hline
              ax\_parameter        & E                         & E                         & G                         & G                  \\ \hline
              Burst Mode           & R\textsubscript{d}        & R\textsubscript{d}        & N/A                       & N/A                \\ \hline
              Example Code         & U                         & R\textsubscript{f}        & R\textsubscript{f}        & U                  \\ \hline
              Documentation        & U                         & U                         & R\textsubscript{f}        & R\textsubscript{f} \\ \hline
              Interfaces           & G                         & P                         & P                         & G                  \\ \hline
              3rd Party            & A                         & A                         & N/A                       & N/A                \\ \hline
              Error Handling       & P                         & P                         & G                         & G                  \\ 

              \bottomrule
       \end{tabular}
       \caption{Categorisation of Changes }
       \label{table:categories}
\end{table}



\subsubsection{axptz} %Reviewed by JW
The Pan, Tilt and Zoom (ptz) module concerns functionality related to manoeuvring the camera, both mechanically and digitally. We concluded that this change was enhancive, because it is a new feature of the API. There was no secondary motive behind this change, as the change was purely enhancive. The interviewee described how this change, as well as the other changes classified as additions, were all included in the new API at the request of API users. Prior to the change being introduced, there was no API functionality for controlling the camera and as such, it was a high priority addition to the new API. The interviewees' comments allowed us to conclude that we had correctly identified the change as being enhancive. Furthermore, we were also correct in our prediction that there was no secondary change category. 

\subsubsection{axaudio} %Reviewed by JW
The most important functionality of the camera is to capture and analyse video data, however, some API users require the ability to analyse audio data. The addition of axaudio allows API users to perform audio analysis of audio streams captured by cameras. This change was determined to be enhancive, as it was an addition of a new feature to the API. We found no secondary motive for the change. Audio analysis had previously not been supported in version 1.4 of the API. However, during the interview, it was revealed that an API user had managed to implement their own audio analysis application using version 1.4 of the API. Given the apparent demand for audio analysis, it was included in version 2.0 of the API.Taking into account the interviewee's reasoning, we concluded that we had successfully determined that the change was enhancive. The addition of axaudio had no secondary motive. 

\subsubsection{axstorage} %Reviewed by JW
Prior to the newest version of the API being released, the sole alternative for storing data was to use the Video Management System. Version 2.0 added the possibility of alternative storage solutions, by allowing the camera to interface with external storage devices, such as SD cards. Enhancive was chosen to be the primary category of change, given that axstorage was a new addition to version 2.0. No secondary motive was identified. The interviewee described how limited storage options for the cameras, in version 1.4, was the reason that increased functionality was strongly requested by API users. As such, axstorage was included in version 2.0 of the API.The information gathered from the interview therefore supported our original categorisation; it was an enhancive change. No secondary category was established. 

\subsubsection{axserialport} %Reviewed by JW
The addition of axserialport allows API users to connect various devices to the cameras through the use of a serial port. This allows users to integrate multiple devices to create their own unique solutions. This was not possible in version 1.4 of the API. The addition of this module was determined to be an enhancive change, as it involved the addition of a new feature. No relevant secondary category was identified. The addition of axserialport was requested by API users to allow them to connect the cameras to other devices. A possible use case, that was given during the interview, involved a ticketing system which allows for joint analysis of data from multiple devices. As such, it was included in version 2.0, to meet the demand of the API users. Given this information, we concluded that we were correct in categorising this change as enhancive. The categorisation of the secondary category was also correct. 

\subsubsection{axevent} %Reviewed by JW
Version 2.0 of the API was designed to be an event-driven system that makes use of callbacks. To achieve this, the old event system had to be re-designed. The new design is used by all features of version 2.0 of the API. An example of when an event would be generated, is when the camera detects movement.  Given that this module was a re-implementation of the previous event system, we concluded that it should be categorised mainly as an enhancive change with the secondary change as groomative. Groomative was chosen as the secondary category due to the additional motive of bringing the new functionality into line with the new design. The interviewee outlined that the previous version of axevent, event, was deprecated in favour of a re-implementation of the new event system. One reason was that the case company was dissatisfied with certain usability aspects of API version 1.4. The module was then completely re-implemented and re-designed according to the new system design of version 2.0. From the discussion in the interview, it was clear that both of our categorisations were correct. The change was primarily enhancive and secondarily groomative.

\subsubsection{axhttp} %Reviewed by JW
The module axhttp serves to provide a Common Gateway Interface which allows the camera to dynamically send data to web pages. The previous version of axhttp was re-implemented in version 2.0, to correspond with the new design standards, and at the same time, additional functionality was added to the module. This change re-implemented an existing module while adhering to the new design of API version 2.0. The main categorisation therefore was chosen to be enhancive with groomative as the secondary category. The interviewee described that the main driving force behind this change was to re-implement and add new functionality to the axhttp module, within the standards of the new design.  Our categorisation of enhancive and groomative was therefore correct for this change. The primary intent was to add functionality while also allowing the re-implementation to make use of the new API design. 

\subsubsection{ax\_parameter} %Reviewed by JW
The parameter setting module of the API allowed data and application settings to be saved so that they are not lost if the device is not running. This module was re-implemented as ax\_parameter with added functionality and conformance to the new design standards of API version 2.0. Given that this change re-implemented an existing module while also incorporating the new design standards, it has been categorised as being primarily enhancive with a secondary category of groomative. The interviewee clarified that this change was mainly concerned with re-implementing existing functionality, while simultaneously adopting the new standards of version 2.0.  Given the information from the interview, we concluded that this change was correctly categorised; the primary intent was enhancive and the secondary intent was groomative.


\subsubsection{Burst Mode} %Reviewed by JW
The burst mode feature of the API allowed users to buffer a series of images for greater analysis. This feature was deprecated during the transition between version 1.4 and 2.0 and was not re-implemented. This change presented itself as a clear example of reductive maintenance, as it was simply removed and without being replaced. We therefore gave no secondary categorisation for this change. The interviewee described, that in order to continue using this feature, it would have to be re-implemented. An impact assessment was undertaken to determine if the removal of the function would be costly. Ultimately, the negative effects were not deemed significant enough and thus the function was removed of the API. We can therefore conclude that we correctly categorised this change as reductive and that there are indeed, no secondary categories to describe this change.


\subsubsection{Example Code} %Reviewed by JW
The case company included a selection of example programs to assist developers with creating applications. This trend continued in version 2.0, but there were some significant improvements. The number of example programs and the amount of comments accompanying the code increased, thus improving quality of the examples. We therefore concluded that this change was updative, as the example code was updated according to the new API and the new techniques that it utilises. We further decided that this change also had a secondary category of reformative. During the interview, it became clear that the improvement of the example code was an important change between the two versions. The interviewee described how the examples were used frequently by their customers, however, the old examples had many varied implementation techniques, even for similar tasks. This ultimately meant that the old examples were not satisfactory and that new examples would have to be written, preferably conforming to the same standards. The new example code explicitly covered the new functionality, focusing on new features and showing how they can be combined to create applications. With this information, we concluded that our categorisation was incorrect. It became clear that this change was, in actual fact, primarily reformative. It was also clear that the subcategory should therefore have been updative. 

\subsubsection{Documentation} %Reviewed by JW
As the API code was updated in version 2.0, the API documentation was updated to correspond with the new code. While there were no substantial changes, we found that the documentation is no longer offered as a PDF but is instead only offered as HTML.  We categorised this change as being updative with a reformative secondary category for the reasons that the change only updated the documentation to reflect the recent changes in version 2.0. This sentiment was shared by the interviewee; the documentation was only changed according to the current workings of the API and how the new modules interact with each other. We can therefore say that our categorisations were correct, the change was updative and reformative.

\subsubsection{Interfaces} %Reviewed by JW
Version 1.4 of the API allowed direct access to the headers of each module available in the API. Version 2.0 changed this by including interfaces through which functionality is accessed. This design change has had an effect on the whole API, as it has changed the structure of modules, but not the functionality of them.We therefore concluded that this change would be best categorised as  groomative. The secondary category was categorised as preventive, as the change could be seen as an attempt to reduce future maintenance. The interview provided further insight into the reasoning behind this design change. Improvements to coding standards, the desire for an event driven system and difficulty in using the existing APIs were all contributors to the decision to use interfaces in versions 2.0 of the API. Furthermore, the re-design would hopefully avoid future maintenance, while also allowing the system to be easily extended. Taking this information into account, we concluded that our categorisation was incorrect. The interview showed that the primary categorisation should have been preventive, given the strong emphasis on avoiding future maintenance and improving usability. We further concluded that the secondary change should have been groomative, to better reflect the intent of improving the APIs maintainability.

\subsubsection{3\textsuperscript{rd} Party}
%% REMEMBER TO PROVIDE LINK TO GLIB:::: - https://developer.gnome.org/glib/
ATTN: (!!!We are waiting for more information from Johanna to confirm / add to this section!!!)
%%Describe the change 
2.0 utilises more 3rd party libraries
axsound, for example, uses alsa
All modules use glib
The advent of the new API saw the inclusion of new 3\textsuperscript{rd} party libraries. For example, axsound utilises a library called Alsa, all interfaces use Glib and daemons have been provided for using D-Bus. These changes potentially make the library much more flexible both for the API designers in terms of features they can provide and for the application developers in terms of applications they can develop.
We therefore gave this change the main categorisation of adaptive with no suitable sub-categories being found.
The architects creating the API decided they wished to use Glib which came about primarily from internal discussions at the company.
%%Relate it to Categories
Architects decided to use glib, part of an internal decision. 
Glib (!!!ref to website) was therefore introduced to the new API to help alleviate this 
The new API utilises Glib in the majority of its interfaces and considering the fact that Glib has its own type of error handling, it seemed sensible to implement the same technique into the new API. However, it was expressed to us that the error handling would have changed between versions regardless of whether or not Glib was included. (!!!This is also too assume-y)

\subsubsection{Error Handling} %Reviewed by JW
A substantial change included in version 2.0 was the addition of header files, containing enums of error codes. While it was not evident how the error handling was implemented prior to version 2.0, we concluded that it had changed, given the addition of the new header files. We therefore categorised this change as being primarily preventive, as error handling is preventive by nature. Groomative was decided as the secondary category of maintenance, as improvement of error handling could be regarded as an attempt to improve maintainability.  During the interview, it was made clear that the previous error handling was lacking in expressiveness and usability. Glib was added to version 2.0 and the error handling functionality that Glib provides was incorporated into the new API design. We therefore concluded that our categorisation for this change was correct. The primary reason for the change was to improve the existing error handling while conforming to the new API standard. 



\subsection{RQ2 Results} \label{results_rq2} %Reviewed by JW
\noindent
RQ2: \textbf{How do APIs ``passively'' evolve?}
\smallskip

The results related to \textbf{RQ2} are structured around each of Lehman's laws of software evolution \cite{lehman1980programs} and to what extent our findings show that the laws apply to platform APIs. A summary of our findings can be seen in Table \ref{table:lehman}. 


\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Law}                              & \textbf{Applicability}    \\ \midrule
              Continuing Change                         & True                      \\ \hline
              Increasing Complexity                     & Kinda                     \\ \hline
              Self Regulation                           & True                      \\ \hline
              Conservation of Organisational Stability  & False                     \\ \hline
              Conservation of Familiarity               & True                      \\ \hline
              Continuing Growth                         & True                      \\ \hline
              Declining Quality                         & Kinda                     \\ \hline
              Feedback System                           & True                      \\ 

              \bottomrule

       \end{tabular}
       \caption{The applicability of Lehman's laws}
       \label{table:lehman}
\end{table}



\subsubsection{Continuing Change} %Reviewed by WJ
The case company described that including new functional content was one of the top priorities for the release of version 2.0. This is supported by the characteristic of the changes identified in this study. 4 of the 13 changes were additions of new modules, and additional functionality was also added to re-implemented modules. It was also mentioned that the API users had previously requested more frequent updates to the API, despite the drawbacks this could cause. One of the main reasons for continuously adapting the API is also to control the way API users use the API. Prior to version 2.0 being released, a number of API users used workarounds to implement applications which contained functionality which was not yet offered from the API. These applications were fully functional, but there existed no standard method of implementation. We therefore conclude that the law of continuing change holds for APIs. 

\subsubsection{Increasing Complexity} \label{sec:law2} %Reviewed by WJ
A majority of the changes introduced in version 2.0 aimed to improve the structure and the way that the API was used. Many of these changes were related to the same design choices, which enforced a certain implementation style on the whole API. One example of this is the change to the interfaces which set a standard for the whole API. During the interview it was also concluded that consistency and following certain standards is an important factor to consider when designing APIs. It was also made clear that a contributing factor for changing certain parts of the API was to bring it into line with the new interface design. The interviewee mentioned that one way of achieving this was to follow guidelines or design best practices, but that the company currently did not make use of these. Even though the importance of maintaining the API in order to reduce complexity was stated, arguments which support that it is of lesser importance than releasing functional content was also presented. One example of where this is evident in the evolution of the API, is in the module that handles the video capturing and video stream. It was decided that this module would not be re-designed to conform with the new interface standard, as the changes to functionality in this module were very minor. Thus, the law of increasing complexity holds for APIs, but there is evidence that suggests that decreasing the complexity is not of the highest priority. 

\subsubsection{Self Regulation} \label{sec:law3} %Reviewed by WJ
The release of version 1.4 did not include any changes related to the API interface. Version 1.0 through to 1.4 strictly added support for additional build target platforms. When comparing the changes introduced in version 2.0 to the ones in previous versions, it is clear that the growth of the API has gradually increased. During the interview it was also mentioned that the future plans for the API did not include any major changes and that only a few minor changes were planned in the near future. The future updates to the API will also be made incrementally and there will not be a big bang update similar to that of version 2.0. This supports that the law of self regulation applies to APIs, assuming that version 2.0 can be considered to be the peak of the normal distribution curve of the APIs growth. 

\subsubsection{Conservation of Organisational Stability} %Reviewed by WJ
The changes to the API have been made very sporadically, where only two new versions have been released since the deployment of version 1.0. As mentioned in Section \ref{sec:law3}, the changes introduced in version 1.4 did not involve any changes to the existing API functions. Consequently, the only significant update to the API was made in the transition to version 2.0. The internal development of the API has also been made sporadically and there have been periods where the API has not been actively developed. This suggests that the law of conservation of organisational stability does not apply to APIs. 

\subsubsection{Conservation of Familiarity} %Reviewed by WJ
The documentation that is included with the API was rigorously updated with the introduction of version 2.0. All functionality which was added or modified in version 2.0 was updated accordingly in the documentation. The same pattern can be seen for the example code, which went through major changes as a result of the changes to the API code. The case company's intent to control the way that their API is used also suggests that the knowledge of how to use the API is of importance, since if the API is used in too many different ways, it will be more difficult for the case company to have relevant documentation and example code. It was also expressed during the interview that further transparency in how the API should be used could be achieved. One example mentioned of how this could be achieved is by improving the expressiveness regarding which API functions are supported on which hardware types. These facts support that the law of conservation of familiarity is true for APIs. 

\subsubsection{Continuing Growth} %Reviewed by WJ
Large parts of the changes between the versions were strictly additions of new functional content. 4 new modules were added and significant additions of new functionality were added to the modules which were re-designed from version 1.4. The interviewee also made it clear that increasing the functionality was one of the main goals with the 2.0 update. This also ties in with the ambition of controlling the way that the API is used, as mentioned previously. It was also mentioned that the case company had received feedback from the API users that more frequent updates to the functional content was desirable, even though this may require them to update their application code. We therefore conclude that the law of continuing growth applies to APIs. 

\subsubsection{Declining Quality} %Reviewed by WJ
The interviews established that a groomative motive was not the primary reason for implementing any change. The changes to the example code and the documentation, as well as the re-designed modules are examples of these, where the main motive behind the change was to either prevent unwanted usage or to increase the functional content. These changes did, however, also increase the quality and were a substantial part of the update. A counterargument to this reasoning can be seen in the module which handles the video data and capturing, which was not changed between the versions, as mentioned in Section \ref{sec:law2}. We therefore settle that the law of declining quality can be applied to APIs, but that there is data that implies that reducing quality is not of high importance. 

\subsubsection{Feedback System} %Reviewed by WJ
One of the future goals of improvement of the case company is to better include the API users and end-users of the applications in their feedback loop. Currently, only the API users are included in this feedback loop and the API architect expressed the desire to also include the end-users. The reasoning for this was to increase the quality, and to be able to deliver content which is useful for the users and which leads to good applications being developed. Prior to version 2.0 being released, an example of how the API users were included in the feedback loop was when they implemented functionality related to sound, despite the fact there was no interface for this.  The experiences of this API user, were later considered when developing the axsound module. One benefit of having a more structured feedback loop, would be that the API developers would have greater awareness of potential errors in the implementation of the API. Another ambition which was mentioned, was to bring scientific theories and best practices from academia into consideration when developing the API. This would aim to complement the current strategy which is largely based around the expertise and experiences of the API architects. Based on these factors and clearly expressed ambitions, we conclude that the law of feedback system is true for APIs. 

\section{Discussion} \label{discussion}%Reviewed by JW
Our results have provided valuable insight into the motives behind the evolution of APIs. The results show that APIs definitely can be studied from the point of view of long-established software evolution theories. Based on the results, we have formulated the subsequent outcomes. 

\subsection{Discussion RQ1}  %Reviewed by JW

\noindent
\textbf{Functionality is a prime driver of API evolution  }  %Reviewed by JW
Overwhelmingly, the primary driving factor behind API evolution was the desire for new API functionality. We found that a vast majority of the changes either added functionality or were a direct consequence of increased functionality. The main driver for these changes was the pressure from API users, but pressure from the case company developers who utilise the API also contributed. This focus upon functionality was also emphasised partially due to a business goal. The more features the API can provide, the more applications developers can create for the cameras. This has a domino effect of increasing the appeal and therefore value of the products.

\smallskip \noindent 
\textbf{Maintainability does not drive change  }  %Reviewed by JW
While maintainability is important, it is not a primary driving factor for change. We found that where changes that effected maintainability, functionality had also been added or modified. Of the changes identified, none were considered to be primarily groomative. Groomative motives were only found to be secondary, and were never the main motive for a change. Changes to the example code are an instance of this. The example code was updated purely to reflect the changes in functionality and not as a groomative effort. 

\smallskip \noindent
\textbf{Standardising application development  } %Reviewed by JW%Reviewed by JW
Supporting users of the API in creating correct and robust applications is a very important evolution factor for the case company. Changes between the versions introduced improvements to error handling, the example code and the way in which the API utilises interfaces. This, coupled with removal of unwanted functionality and unsafe operations, has allowed the API to grow and become much more user-friendly. As mentioned previously, this could increase the amount of applications being created for the camera and as a consequence, could potentially increase the value of them.

\smallskip \noindent
\textbf{Removing functionality  } %Reviewed by JW
Previous literature has suggested that deprecating functionality is the most common technique used to remove support for specific functionality. Removals are only suggested in specific circumstances. The successful removal of the burst function seems to indicate that under the correct circumstances, removing specific functionality is an alternative that should be considered. The case company removed this function from the API, after an internal review found that the potential negative effect the removal could have, would be less impactful than further maintenance of the function. We therefore recommend to remove functionality of an API if the effect of the removal has been thoroughly investigated and that the removals happen incrementally.

\smallskip \noindent
\textbf{Documentation does not drive change  } %Reviewed by JW
The intent to update example code and documentation was described by the interviewee to be an important change between version 1.4 and 2.0. While important for the APIs usability, it was not a driving factor of change itself. The changes to the APIs' design and functionality caused the need to update the documentation and example code.

\smallskip \noindent
\textbf{Hardware is not a driving factor  } %Reviewed by JW
Our initial expectations included the view that changes to hardware would be one of the strongest driving factors of API evolution. One example could be if new cameras are created or new hardware is added to an existing camera, which would require updates to the API to allow use of the new features. However, after analysing the changes and from the information gathered in the interview, we discovered that hardware has played a minimal role in the evolution of the API. 


\subsection{Discussion RQ1.1}

\noindent
\textbf{Functionality is reverse engineerable  } %Reviewed by JW
All changes whose main motive was to either add or remove functionality were accurately predicted. These changes were the most significant and it was expressed during the interview that these types of changes were the main driving factors behind the development of the new version. In summary, eleven out of a total of thirteen changes were correctly predicted. It is also interesting to note that all changes which were not assigned any sub-category were correctly predicted. This supports the fact that such changes have a clearer intent and are perhaps more well-defined.

\smallskip \noindent
\textbf{Design changes are reverse engineerable to some extent  }  %Reviewed by JW
Three out of five changes which did not add functionality, but rather were introduced to reduce complexity and increase quality, were correctly predicted. The two changes which were incorrectly predicted were inaccurate because the main motivation was confused with the secondary intent. This shows that, although the prediction was incorrect, the general reasoning was correct. Our predictions were accurate enough to allow us to form a reliable conclusion which provided valuable discussion with the case company. 


\subsection{Discussion RQ2}

\noindent
\textbf{A majority of the laws apply  } %Reviewed by JW
Sufficient evidence was found for the laws of Continuing Change, Self Regulation, Conservation of Familiarity, Continuing Growth and Feedback System to establish that they apply to APIs. The most prominent explanation for this is that a large part of the introduced changes were related to functionality. It is especially interesting to note that the laws of Self Regulation and Conservation of Familiarity accurately match the API explored in this paper. 

\smallskip \noindent
\textbf{Two laws apply to a certain extent  } %Reviewed by JW
The laws of Increasing Complexity and Declining Quality were found to apply to APIs, but the extent to which they apply might not be as significant for APIs compared to other types of systems. The reason that this doubt exists is because these motives were secondary to the motives of increased functionality. An alternative explanation for these laws being of lesser significance in APIs could be that the general inertia to modify APIs which exists \cite{google_talk} \cite{henning2007api} \cite{mcdonnell2013empirical} \cite{robbes2012developers} might dominate the need to improve simplicity and quality. 

\smallskip \noindent
\textbf{One law is not applicable  } %Reviewed by JW
Strong evidence was found to suggest that the law of Conservation of Organisational Stability does not apply to APIs. Our results not only show that the law is not true for APIs, but that the opposite of what the law states is true for APIs. This is supported by the consensus in literature of the negative effects caused by modifications to APIs \cite{google_talk} \cite{henning2007api} \cite{mcdonnell2013empirical} \cite{robbes2012developers}. The results from our study also revealed that reluctance to change APIs causes the releases of new versions to be few and sporadic. 

\smallskip \noindent
\textbf{The importance of a Feedback System  } %Reviewed by JW
Especially interesting results were found in regards to the law of Feedback System. The importance of having a structured and developed feedback loop was stressed during the interview and it was also expressed as one of the main points of improvement. This suggests that including feedback from more sources and using this feedback to improve the evolution process should be a consideration for APIs. 






\section{Conclusion} \label{conclusion}
ATTN: This section has not been started. 

1. Small intro which: Summarises the findings of the discussion

2. Conclusions/outcomes:
Industry
Have a more structured feedback loop (include users) this can be future work too
              Greater emphasis should be placed upon communicating with the end users / application developers. They should probably improve their feedback system to get more feedback from the API users.
              Include more scientific theories
              --> consider ecosystem stuff

Academia
Some laws dont apply. Propose a new version of the law.
Interesting that hardware did not drive change. This is cool cuz it means hardware apis can be generalised to any type of api.
Since motives are reverse engineerable, it hsould encourage more ppl to do similar studies
%%William add conclusion ideas here
That the part about controlling how the API users use the API was such an important thing is interesting. (Not something we expected). 
       MAke a study which looks the quality of applications before and after api changes have been introduced

3. Future work: Summarise what the next steps could be.
Obvious benefit for Axis is that the more features == more applications == higher value for their camera. If they have many applications being developed by partners (In part due to the fact they have added more features to the camera API) then the value of their hardware and software will increase. This is probably the case for many other APIs but would need to be studied in some detail to determine the truth behind the statement.
       -->Suggest a similar study which looks at business factors


Random tips n trickz:
       Look up the papers from the conference (especially regarding the discussion/conclusion)
       discussion = revisiting research questions (and maybe structuring around industry/academia)
       conclusion = summary part, main final points and future work 





\section{Acknowledgements}
We would like to thank Axis and that project at GU. 

\bibliographystyle{abbrv}
\bibliography{bib} 






\end{document}
