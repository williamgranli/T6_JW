

\documentclass{sig-alternate}
\usepackage{blindtext}
\usepackage[english]{babel}

%
\usepackage{array}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{booktabs} 


%Used for \textsubscript
\usepackage{fixltx2e}

\usepackage{url}



\begin{document}


\conferenceinfo{14th IWPSE} {'15 Bergamo, Italy}
\CopyrightYear{2015}

\crdata{1-23456-78-9/01/23}


\title{The Driving Forces Behind API Evolution}


\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
John Burchell\\
%       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{john.a.burchell@gmail.com}
% 2nd. author
\alignauthor
William Granli\\
%       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{william.granli@gmail.com}
%\and
% 3rd. author
%\alignauthor Imed Hammouda\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
% 4th 
%\alignauthor Eric Knauss\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
}

\maketitle

\begin{abstract}


\textbf{Background  } %Give a feeling of the need of this study, answer why Axis needs what is in the Objective (+Context)
The driving forces of modifications to APIs have been investigated before, however, platform APIs are, until now, unexplored. Previous studies have not considered APIs from the perspective of well-established software evolution theories. 

\smallskip \noindent
\textbf{Objective  } %Done
In this study, we explore how companies actively evolve their APIs and 'how APIs evolve from a passive point of view'. We also aim to evaluate to what extent we are able to reverse engineer these evolutionary change decisions. The goal is to study these factors by evaluating them against existing software evolution theories. 

\smallskip \noindent
\textbf{Method  } %Done
This case study was conducted by analysing the changes between two versions of a platform API and its documentation. The results were analysed from a qualitative and investigative perspective, and were then reviewed and validated with the architects of the API. 

\smallskip \noindent
\textbf{Results  } %Done
We identified thirteen major changes which were introduced in the new version of the API. We concluded that the dominant driving force of the API evolution is demand for new functionality and that change decisions, to a large extent, are reverse engineerable. We also found that long-established software evolution laws were largely applicable to APIs. 

\smallskip \noindent
\textbf{Conclusion  }
This study has provided valuable insight into the evolution of platform APIs. The qualitative analysis can help other companies to improve their API maintenance process. The successful attempt to reverse engineer the change decisions should encourage similar studies to be conducted. The investigation of Lehman's laws show that APIs cannot be generalised and be compared to any type of system. 



\end{abstract}

\category{D.2.7}{Software Engineering}{Distribution, Maintenance, Enhancement}[Restructuring, reverse engineering, and re-engineering]
\keywords{API Design, Software Evolution, Software Maintenance}







\section{Introduction} \label{introduction}
%API Design (and a little bit of ecosystems and a bit of problem statement)
As the software industry and the open-source movement continue to grow, the number of public APIs is steadily increasing. APIs can improve the development speed \cite{stylos2006comparing}, contribute to higher quality software \cite{stylos2006comparing} and increase the reusability of software \cite{afonso2012evaluating}. There is a consensus in that modifications to APIs could negatively impact the users of the API \cite{google_talk, mcdonnell2013empirical, robbes2012developers, henning2007api}. The main reason for this is that it requires the API users to update the application code, thus causing a disruption in the application's software ecosystem \cite{messerschmitt2005software}. Refactoring is the most common change that APIs undergo \cite{dig2005role, xing2006refactoring}. 
%Software Evolution 
In the discipline of software evolution, such updates to software are studied from an evolutionary standpoint. Software can be updated for different reasons and these motives can be grouped into corrective, adaptive, perfective and preventive changes \cite{lientz1980software}. 

%Gap in Literature
Studies that explore the intent behind API modifications exist \cite{hou2011exploring}. The area of programming language APIs is well-explored \cite{hou2011exploring, shi2011empirical}, but few studies that explore platform APIs exist \cite{robbes2012developers}. To the best of our knowledge, no studies that explore API evolution have until now been performed on embedded platform APIs. 

%switch places between ^ and v

%Purpose
Modifications to deployed APIs may negatively impact its users. It is therefore important to investigate why these changes occur. Understanding the motives behind the changes could help API designers to  prevent potential future changes to their APIs. Before industry can safely include such information in their feedback loop, we must critically assess to what degree we can reverse engineer such motives. 

%Method %wrong tense %include RQs in here %include clear contribution (to johanna)
In order to achieve this, an exploratory case study will be undertaken to investigate the underlying motives behind changes to APIs. Empirical analysis of the changes between two major versions of an API will be undertaken, following which, an interview with the architects will be used to validate the findings of our analysis. 

%Can't find a place for this - it's repeated in the Purpose
%Reverse engineering design decisions is a challenging yet interesting problem. The better we can understand why changes occur and what problems they are trying to solve, the better we can design around these problems to avoid them cropping up in the future.


\subsection{Research Questions} \label{rqs}
\begin{description}
\item[\textbf{RQ1}] How do companies actively drive API evolution?
\item[\textbf{RQ2}] How do APIs ``passively'' evolve?
\item[\textbf{RQ3}] To what extent can we reverse engineer API change decisions?


\end{description}

%Structure of the paper
The sections following the Introduction are structured as follows: In Section \ref{background}, we present the background and previously published work that is related to our study. Section \ref{case_company_description} describes the case company and the API which was studied. A description of our methodology is introduced in Section \ref{methodology}. In Section \ref{results}, the results of our study are presented and in Section \ref{discussion}, we discuss the findings of our study. In Section \ref{conclusion} we propose the potential impact of our work and give suggestions for future work that builds on our research. 

\section{Background} \label{background}
This section will introduce the fields of API design and software evolution, and provide a review of studies that are directly related to our study. Follow that, we will introduce the company and API examined in this study. 


\subsection{API Design} \label{api_design}
API design is notoriously difficult, as a myriad of design and performance decisions must be taken into consideration when creating APIs \cite{afonso2012evaluating, bloch2008effective, stylos2006comparing}.

Examples of such design decisions include how to structure an object's constructor parameters or if the API should display errors at compilation or at runtime \cite{stylos2006comparing}. More trivial design problems, such as assigning names to API features or correctly naming user-defined types, can have a significant impact on the usability of an API \cite{shi2011empirical}. When facing such design challenges, the following four factors are important to consider: a) The API must be understandable through good documentation, b) the API must not be overly abstract, c) the API must be reusable and d) the API must be easy to learn \cite{shi2011empirical}. One of the most important qualities in an API is that the intent of the API must be clear to the user \cite{stylos2006comparing, shi2011empirical}. The design decisions reached during development of an API will affect the overall usability of the API. Measuring such an effect can be done by investigating the twelve cognitive dimensions that are impacted by interactions between the API and its users \cite{clarke2004measuring}. 


\subsection{Software Evolution} \label{software_evolution}
%%Types of maintenance and types of maintenance
Software evolution is a field that studies the application of software maintenance activities, changes in software processes and the resulting, evolved versions of the software. The concept of software maintenance has existed since the 1960s when it was first introduced to the software development community \cite{lientz1980software}. A set of four categories describing different types of software maintenance \cite{lientz1980software} became the basis upon which twelve new types were developed \cite{chapin2001types}. The twelve types of software evolution and software maintenance, as seen in Table \ref{table:expl_types}, describe a software evolution activity that relates to one of three particular areas; the code, the software and the customer-experienced functionality. 

%Re-write this section... it's wrong
Software evolution theory suggests that changes to software must obey one of eight laws \cite{lehman90sview}. The laws, known as Lehman's laws, are: 1) Continuing Change, 2) Increasing Complexity, 3) Self Regulation, 4) Conservation of Organisational Stability, 5) Conservation of Familiarity, 6) Continuing Growth, 7) Declining Quality and 8) Feedback System. The laws are said to only apply to E-type systems, which are programs that solve problems or address applications in the real world.     

\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Type}                              & \textbf{Explanation}    \\ \midrule
              Corrective    & Corrections of functionality                   \\ \hline
              Reductive     & Reductions of functionality                    \\ \hline
              Adaptive      & Inclusion of new Technology                    \\ \hline
              Performance   & Improvements to Performance                    \\ \hline
              Preventive    & Improvements to future maintainability         \\ \hline
              Groomative    & Improvements to maintainability                \\ \hline
              Updative      & Updates to documentation                       \\ \hline
              Reformative   & Changes to documentation                       \\ \hline
              Evaluative    & Inspection activities                          \\ \hline
              Consultive    & Consultations activities                       \\ \hline
              Training      & Training activities                            \\ 

              \bottomrule

       \end{tabular}
       \caption{Explanation of Types of Software Maintenance}
       \label{table:expl_types}
\end{table}




\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Law}                              & \textbf{Explanation}    \\ \midrule
              Continuing Change                         & [Explanation]                      \\ \hline
              Increasing Complexity                     & [Explanation]                     \\ \hline
              Self Regulation                           & [Explanation]                      \\ \hline
              Conservation of Organisational Stability  & [Explanation]                     \\ \hline
              Conservation of Familiarity               & [Explanation]                      \\ \hline
              Continuing Growth                         & [Explanation]                      \\ \hline
              Declining Quality                         & [Explanation]                     \\ \hline
              Feedback System                           & [Explanation]                      \\ 

              \bottomrule

       \end{tabular}
       \caption{Explanation of Lehman's Laws}
       \label{table:expl_laws}
\end{table}


\subsection{API Evolution} \label{related_work}
The analysis of APIs in the context of software evolution has primarily focused on APIs that are part of large programming languages, such as Java \cite{hou2011exploring, shi2011empirical} and Smalltalk \cite{robbes2012developers}. Attempts to uncover the intents behind the changes made in the AWT and Swing Java libraries have also been undertaken \cite{hou2011exploring}, leading to suggestions that the use of a strong architecture is vital for ensuring the successful evolution of an API \cite{hou2011exploring}.

Investigations of three frameworks and one library indicated that 80\% of refactoring changes to APIs negatively affected existing applications \cite{dig2005role}. The changes, sometimes referred to as ripple effects \cite{robbes2012developers} indicate that negative effects of changes can propagate throughout a software ecosystem. It was found that 14\% of non-trivial API deprecations caused errors in at least one project, with the worst case of 79 projects being affected \cite{robbes2012developers}.

%%Possibly add a paragraph here to motivate the gap more



\subsection{Case Company Description} \label{case_company_description}
The case company is a company operating in the domain of video surveillance. The company's headquarters are located in Lund, Sweden, with offices in 49 countries worldwide. The company is the global market leader in the markets of network cameras and video encoders. They develop embedded software for security cameras. The cameras are designed to be accessible through APIs that are developed and maintained by the company. 

The API analysed in this study is written in the programming language C and has been deployed for several years. It was recently updated from version 1.4 to version 2.0, which is the current active version. The changes between these two versions is what has been analysed in this study. Between the release of version 1.0 and 1.4, no functionality was added, as it only added additional build options for other hardware platforms. Prior to version 1.4 being released, updates were only made to include additional built options and did not include any additional functionality. The API is used by company partners, which are companies who develop applications for the cameras. These applications are, in turn, used by the end-users of the cameras. The API is developed for a wide range of camera types that offer different functionality and are used for different purposes. 




\section{Methodology} \label{methodology}
%Intro and summary
This study has been conducted using the case study methodology \cite{runeson2009guidelines}. The goal of the study was twofold. Firstly, the aim was to empirically explore the motives behind changes to APIs and secondly, to validate the results' level of correctness by comparing our findings with the case company's explanation of their motives. Our research can be classified as an embedded case study \cite{yin2013case}, since both the API code and API documentation have been used as units of analysis. 

%Reasons for choosing case study
The reason the selected methodology was used is that it is essential to study the phenomenon of API change in its natural context. The applicability of case studies in such scenarios is supported by existing literature \cite{benbasat1987case, runeson2009guidelines, yin2013case, robson2002real}. An alternative approach that was considered was design research, but if a prototype API was to be used instead of one which is tried and tested in an industry setting, the study would lack real-life context \cite{runeson2009guidelines}. An additional motivation for why the case study approach was used is that there is little existing research conducted in the area of motives behind API change and that input from the industry is vital to the success of the research, especially to be able to answer \textbf{RQ3}. 

The study was conducted in two major phases \cite{andersson2007spiral}. The aim of the first phase was to generate hypotheses and to formulate clear research questions. This was achieved by using a data-driven approach to analysing the code and documentation. The second phase included analysis of the interviews, during which we aimed to confirm the hypotheses that were formulated in the first phase. Both phases were performed iteratively. This created the opportunity to improve the data analysis as the study progressed, as well as allowing us to adapt to possible changes in direction, due to the hypothesis generating approach of the first phase. 

The process used for examining the code and documentation was inspired by grounded theory analysis \cite{seaman1999qualitative}, as it is recommended for hypothesis generating studies \cite{runeson2009guidelines, seaman1999qualitative}. 






\subsection{Data Collection} \label{data_collection}  
%Intro to code inspection
The data were collected primarily through inspections of the source code and the analysis of accompanying documentation. The source code was comprised of the two API versions previously mentioned. Each version of the API had its own respective documentation, including example code, a library description and a basic development manual. 

%How the initial inspection was performed
The API code was inspected sequentially, starting with version 1.4. Both versions of the API underwent the same inspection. This involved extracting method signatures, enums, structs, typedefs and macros, which were subsequently stored in spreadsheets. The extraction involved a lot of manual work, but Git's \cite{git} diff command was used to identify changes in files which exist in both versions. After a change was identified in the code, a description of the corresponding change in the documentation was added to the spreadsheet. The module and file in which the change was identified was then logged together with an ID and a description of the change. The data collection from code and documentation was performed independently by both John Burchell and William Granli, to reduce the risk of human errors affecting the results. If the data collected by each researcher differed, the cause of the discrepancy was investigated and resolved. 

%Purpose of the interview
After the initial source code inspection and preliminary analysis had been performed, an interview was conducted. The main purpose of the interview was to validate our findings from the code inspection with the API architect. The interview also served the purpose of providing additional insight into what drove the evolution of the API, by complementing what was found from the code inspection. The final reason for interviewing the API architect was to gather information about the API users and how their decisions, needs and requirements have affected the development of the API. 

%Structure of the interview
The interview was conducted using a semi-structured approach \cite{robson2002real}. Structure to the interview was provided by organising it around the software evolution theories \cite{chapin2001types, lehman90sview}. Investigative and open-ended questions related to each type and law were asked to provide a basis for comparison between the answers and our initial analysis. The interviewee was encouraged to speak freely, even if it required a change in direction or topic. This was allowed in order to fulfil our exploratory goal of the study. 




\subsection{Data Analysis} \label{data_analysis}

%Codes
To analyse the data each change identified in the spreadsheet was coded based on which module the change occurred in and two other characteristics: a) if the change added, removed or modified functionality, and b) if the change was a cosmetic change or not.
%Concepts
Grouping the codes by module allowed us to form general concepts of change. However, changes that affected the whole API were classified on their own. %"that affected the whole API" re-word this
%Categories
These concepts were then grouped into categories based on common patterns between the concepts.
%Theory
These categories were then used to identify the most notable trends in the evolution of the API. These trends were later used as a basis for discussion during the interview.

%RQ1
The trends identified previously were then classified according to the software maintenance types \cite{chapin2001types}. The process followed the decision tree used for classifying the types of software evolution and software maintenance \cite{chapin2001types}. Each of the previously identified trends were given a main type of maintenance and, if appropriate, a secondary type. This material, as well as the results of the interview, were then used as the basis for answering \textbf{RQ1}.

%RQ2
The analysis of the changes and trends, combined with the information gathered from the interview, allowed us to answer \textbf{RQ2} by determining if Lehman's Laws apply to the changes made to the API. 

%RQ3
To allow us to answer \textbf{RQ3}, we compared our analysis and interpretation of the trends identified prior, against what was expressed by the API architect, during the interview. Success was determined by comparing the inter-rater reliability, by performing calculating Cohen's Kappa gathered data. 





\subsection{Validity Threats} \label{validity_threats} %Review 1 or 2 more times (John first)
In this section we discuss possible threats to construct validity, internal validity, external validity and reliability \cite{runeson2009guidelines}.

\smallskip \noindent
\textbf{Construct validity  } Threats to construct validity have largely been mitigated by structuring the results of the study around already established and accepted software evolution theories \cite{chapin2001types, lehman90sview}. Due to restricted access to the company's source code, we were not able to include versions prior to version 1.4 in our analysis. This means that the evolution of the API was studied during a rather short period of its lifetime. It was also not possible to analyse the implementation of the API, something which might have contributed to more accurate predictions of the motives behind the changes. We consider these factors to be the remaining threats to construct validity. 

\smallskip \noindent
\textbf{Internal validity  } Limitations related to internal validity have been acknowledged by analysing the code and documentation jointly. This has contributed to triangulating the results and discovering possible inconsistencies. Further triangulation of the results was performed by interviewing the API architect. Business-related factors might have had an impact on the evolution of the API, and these were not closely investigated. This was not in the scope of the study and would best be investigated in a study complementary to ours. The study revealed that the API users were significant to the evolution of the API. Since API users were not interviewed, it might be an affecting factor which was left unexplored. 

\smallskip \noindent
\textbf{External validity  } The results of our study should be highly generalisable to similar studies conducted on any type of APIs, since the evolution of the API has largely been driven by software-related factors. Our study can especially be compared to similar studies conducted on platform or embedded APIs. Further comparability to our study is offered through how the results are structured around established software evolution theories. 

\smallskip \noindent
\textbf{Reliability  } Potential threats to the reliability of our study have, to a great extent, been reduced by conducting the study according to an accredited guide to case studies \cite{runeson2009guidelines}. In addition to that, strategies from additional well-established papers \cite{andersson2007spiral, seaman1999qualitative, robson2002real} have been used to increase the trustworthiness of the data gathering and data analysis. The analysis was based around well-defined theories that are cemented in academia, to further increase the reproducibility of the study. The semi-structured nature of the interview, might threaten the reproducibility; however, large parts of it were structured around existing theories. 




\section{Results} \label{results} 
%%Write new

%%Small intro to this section. Mention that : In total, thirteen unique changes were found.

The majority of changes between version 1.4 and version 2.0 have been additions to functionality of the API. Such additions include added functionality to allow mechanical and digital control of the camera, to utilise additional storage devices, to allow serial connectivity and to allow audio analysis on the cameras. Changes that were pure additions the API were not attributed with any secondary types of change.

Many of the changes were deprecations that were later re-implemented as new modules. Changes of these kinds were grouped into a single type instead of two. Such examples include the deprecation and re-implementation of an event system, dynamic web page generation and configuration utilities. Changes of this kind often had an accompanying secondary type of change.

The remainder of the changes were defined as general trends. These changes were not changes to individual parts of the API, but were instead larger changes that affected the whole API. Such examples include a shift towards using interfaces to access features, a different error-handling approach and the inclusion of additional 3\textit{rd} party libraries. Typically, these general trends also have a secondary type of change attributed to them.



\subsection{RQ1 Results} \label{results_rq1}

%Types intro
The results show that certain types of change are more prevalent than others, these results are shown in \ref{table:type_counts}. Analysis of the results showed that enhancive changes were the primary types of change that drive API evolution and that they act as a catalyst for many of the other changes in the API. Updative changes were found to be consequences of enhancive changes, rather than being drivers of evolution. Supporting the users of the API through the combination of preventive and groomative types of change, together formed another strong driver of API evolution. Reductive and adaptive changes, while important, did not strongly drive the evolution of the API. No evidence was found for corrective, performance types of change. Similarly, there was no evidence found for evaluative, consultive nor training activities.    

%Lehman Intro
Our analysis of the results related to \textbf{RQ1} showed that seven out of the eight laws \cite{lehman90sview} do apply to APIs. A summary of our findings can be seen in Table \ref{table:lehman}. The evidence found for the laws of continuing change, self regulation, conservation of familiarity, continuing growth and feedback system mainly relate to enhancive changes that add functionality to the API. It was also found that the laws of increasing complexity and declining quality do apply, but that the changes which support these laws usually had a secondary intent related to complexity or quality. The only law which was found not to apply to the API analysed in this study was the law of conservation of organisational stability. Our results rather show the opposite, that the work rate is variant. 

In the remainder of this section we will discuss the results related to each type of change category, discussing the results for each of them with examples from the changes identified between the two versions of the API. Subsequently, each of Lehman's laws will be discussed and our results will be presented showing if the laws apply to APIs or not.



%Lehman Table
% \begin{table}
%        \centering
%        \begin{tabular}[ht]{l|c}
%               \toprule

%               \textbf{Law}                              & \textbf{Applicability}    \\ \midrule
%               Continuing Change                         & True                      \\ \hline
%               Increasing Complexity                     & True                     \\ \hline
%               Self Regulation                           & True                      \\ \hline
%               Conservation of Organisational Stability  & False                     \\ \hline
%               Conservation of Familiarity               & True                      \\ \hline
%               Continuing Growth                         & True                      \\ \hline
%               Declining Quality                         & True                     \\ \hline
%               Feedback System                           & True                      \\ 

%               \bottomrule

%        \end{tabular}
%        \caption{The applicability of Lehman's laws}
%        \label{table:lehman}
% \end{table}


%Re-write this intro a bit (since I moved it)
All of the identified changes have been given a type based the nature of the change according to the Types of Software Evolution and Software Maintenance decision tree \cite{chapin2001types}. Table \ref{table:type_counts} shows the total count of each type of change found in the different versions of the API.

Functionality is a prime driver of API evolution // Hardware is not a driving factor
Maintainability does not drive change // Documentation does not drive change
Standardising application development
Removing functionality

% \begin{table}
%        \centering
%        \begin{tabular}[ht]{l|c|c}
%               \toprule

%               \textbf{Type}        & \textbf{Main Types}       &\textbf{Secondary Types}   \\ \midrule
%               Enhancive            & 7                         & -                         \\ \hline
%               Corrective           & -                         & -                         \\ \hline
%               Reductive            & 1                         & -                         \\ \hline
%               Adaptive             & 1                         & -                         \\ \hline
%               Performance          & -                         & -                         \\ \hline
%               Preventive           & 2                         & -                         \\ \hline
%               Groomative           & -                         & 5                         \\ \hline
%               Updative             & 1                         & 1                         \\ \hline
%               Reformative          & 1                         & 1                         \\ \hline
%               Evaluative           & -                         & -                         \\ \hline
%               Consultive           & -                         & -                         \\ \hline
%               Training             & -                         & -                         \\ 

%               \bottomrule

%        \end{tabular}
%        \caption{Identified Types of Change}
%        \label{table:type_counts}
% \end{table}


\subsubsection{Types 1by1}

\smallskip \noindent
\textbf{Enhancive  }
%Define how we identified the change type
Additions or re-implementations of functionality are defined to be enhancive changes. In addition to this, we have included deprecations that have then been re-implemented to also be enhancive.
%Some Data and little explanation
Seven of the identified changes were given the type of enhancive. The majority of which were additions of new functionality to the API. Two examples of added functionality are the addition of camera movement module and an audio analysis module. One example of a deprecation that was re-implemented is the event system.
%Conclusion
Given that over half of the changes were identified to be enhancive, we conclude that the APIs evolution primary type of change was enhancive. 

\smallskip \noindent
\textbf{Corrective  }
%Define what kinds of changes these are
Corrective changes are identified as types of change that fix broken functionality.
%Data and explanation
No corrective changes were identified between version 1.4 and version 2.0. There are two main reasons that we did not find any changes of this type. Firstly, the majority of changes were additions or re-implementations of functionality. This meant that most of the existing code was either removed, replaced or deprecated, resulting in little to no obvious fixes. Secondly, we only had access to the public facing API and not the implementation itself. We therefore could not inspect the inner workings of the functionality that has remained between versions to determine if any corrective change took place.
%Conclusion
We therefore conclude that the evolution of the API was not driven by corrective changes.

\smallskip \noindent
\textbf{Reductive  }
%Definition
Reductive changes are defined as changes that remove or reduce functionality. This is distinctive from a deprecation as reductive types of change remove functionality completely.
%Data & Explanation
Only a single reductive type of change was identified. This reductive change removed functionality that provided the ability to buffer individual images for closer analysis by a user. Given that it is more common to refactor APIs and not remove functionality \cite{dig2005role, xing2006refactoring}. It was revealed during the interview that the functionality was removed because the case company no longer wished to support this feature. 
%Conclusion
As this was the only reductive change found, we conclude that the evolution of the API was not primarily driven by reductive changes.

\smallskip \noindent
\textbf{Adaptive  }
%Introduction and definition
Adaptive changes are defined to be changes which involve changes to technology or resources used. 
%Data and examples
A single change was identified as being adaptive; the inclusion of new 3\textit{rd} party libraries. Libraries were added for audio and data communication. The pre-existing low-level library was further incorporated into whole API. (!!!)
%Conclusion 
We therefore conclude that the evolution of the API has not been primarily driven by adaptive changes.

\smallskip \noindent
\textbf{Performance  }
%Define
Performance changes are defined to be types of change that intentionally alter system performance.
%Data and examples
No evidence of performance-driven changes were identified in the API.
%Conclusion
This therefore leads us to conclude that API evolution is not driven by performance changes.

\smallskip \noindent
\textbf{Preventive  }
%Define
Preventive changes are defined to be changes that attempt to avoid future maintenance. This should not be confused with changes that attempt to make the current state of the system more maintainable.
%Data and examples
Two changes were identified to be preventive types of change. A new error handling system was one of these changes. Version 2.0 of the API added specific error handling modules and functions which replaced the pre-existing error-handling in v1.4 of the API. The redesign of the system to make use of interfaces was also classified as a preventive change. Using interfaces to access modules helps to make them more maintainable and more easily extensible.
%Concusion
Preventive types of change appear to drive the evolution of an API more strongly than other types of change. This could be due to the fact that as the API grows, the need for higher maintenance also increase, a fact that also seems to be supported by Lehman's laws.

\smallskip \noindent
\textbf{Groomative  }
%Define
Groomative changes are defined to be changes that aim to immediately make the code more maintainable.
%Data and examples
While none of the change identified were primarily groomative changes, three of them were secondarily classified as being groomative. This indicates that the groomative nature of a change is often a positive affect of other types of change. The move towards using interfaces can be seen as an example of this. While the primary motive of change was to make the API more maintainable in the future, making the API more maintainable immediately was also a reason for the change.
%Conclusion
While not a primary factor for any of the changes, groomative types of change should still be viewed as important for API evolution.

\smallskip \noindent
\textbf{Updative  }
%Define
Updative changes are defined to be changes to documentation of a system.
%Data and example
A single change was determined to be updative; updating the API documentation to include the new functionality of v2.0. The updates included a new API specification, deprecation list and the inclusion of the new features and libraries.
%Conclusion
Updative changes have very little impact on the functionality of the API yet they are still important changes for the usability of the API \cite{shi2011empirical}. Changes to the API cause the need for updative changes to its documentation, without them, the usability of the API could suffer. We therefore conclude that the evolution of an API is not driven by updative changes.

\smallskip \noindent
\textbf{Reformative  }
%Define
Reformative changes are defined to be changes that update the documentation to the stakeholders needs.
%Data and Example
One reformative change was identified between version 1.4 and version 2.0; a redesign of the existing example programs. The aim of this change was to update the examples to illustrate the new functionality in the API, showing how the modules interact and at the same time, presenting a standard for how to use the API.
%Conclusion
We therefore conclude that reformative changes, while important for the usability of the API, do not drive the evolution of the API.

\smallskip \noindent
\textbf{Evaluative, Consultive and Training  }
%Define
Evaluative, Consultive and Training are all types of activities, rather than changes that a system can undergo. Evaluative activities are defined as activities such as auditing or evaluating the software. Similarly, consultive activities involve consultations with customers about the software. Finally, training activities involve training for customers and users of the software.
%Data and example
None of the aforementioned activities occurred as part of the APIs evolution as these activities do not play a role in API evolution. This is supported by the fact none of the activities were identified for the changes.
%Conclusion
We can therefore conclude that these change types are not important for API evolution.


\subsubsection{Laws 1by1} 

\smallskip \noindent
\textbf{Continuing Change  } 
The case company described that including new functional content was one of the top priorities for the release of version 2.0. This is supported by the characteristic of the changes identified in this study. 4 of the 13 changes were additions of new modules, and additional functionality was also added to re-implemented modules. It was also mentioned that the API users had previously requested more frequent updates to the API, despite the drawbacks this could cause. One of the main reasons for continuously adapting the API is also to control the way API users use the API. Prior to version 2.0 being released, a number of API users used workarounds to implement applications which contained functionality which was not yet offered from the API. These applications were fully functional, but there existed no standard method of implementation. We therefore conclude that the law of continuing change holds for APIs. 

\smallskip \noindent
\textbf{Increasing Complexity  } \label{sec:law2} 
A majority of the changes introduced in version 2.0 aimed to improve the structure and the way that the API was used. Many of these changes were related to the same design choices, which enforced a certain implementation style on the whole API. One example of this is the change to the interfaces which set a standard for the whole API. During the interview it was also concluded that consistency and following certain standards is an important factor to consider when designing APIs. It was also made clear that a contributing factor for changing certain parts of the API was to bring it into line with the new interface design. The interviewee mentioned that one way of achieving this was to follow guidelines or design best practices, but that the company currently did not make use of these. Although the importance of reducing the complexity was stated, it was made clear during the interview that one module was not updated between the versions, even though it did not follow the new standards of version 2.0. In conclusion, we establish that the law of increasing complexity is true for APIs. 

\smallskip \noindent
\textbf{Self Regulation  } \label{sec:law3} 
The release of version 1.4 did not include any changes related to the API interface. Version 1.0 through to 1.4 strictly added support for additional build target platforms. When comparing the changes introduced in version 2.0 to the ones in previous versions, it is clear that the growth of the API has gradually increased. During the interview it was also mentioned that the future plans for the API did not include any major changes and that only a few minor changes were planned in the near future. The future updates to the API will also be made incrementally and there will not be a big bang update similar to that of version 2.0. This supports that the law of self regulation applies to APIs, assuming that version 2.0 can be considered to be the peak of the normal distribution curve of the APIs growth. 

\smallskip \noindent
\textbf{Conservation of Organisational Stability  } 
The changes to the API have been made very sporadically, where only two new versions have been released since the deployment of version 1.0. As mentioned in Section \ref{sec:law3}, the changes introduced in version 1.4 did not involve any changes to the existing API functions. Consequently, the only significant update to the API was made in the transition to version 2.0. The internal development of the API has also been made sporadically and there have been periods where the API has not been actively developed. This suggests that the law of conservation of organisational stability does not apply to APIs. 

\smallskip \noindent
\textbf{Conservation of Familiarity  } 
The documentation that is included with the API was rigorously updated with the introduction of version 2.0. All functionality which was added or modified in version 2.0 was updated accordingly in the documentation. The same pattern can be seen for the example code, which went through major changes as a result of the changes to the API code. The case company's intent to control the way that their API is used also suggests that the knowledge of how to use the API is of importance, since if the API is used in too many different ways, it will be more difficult for the case company to have relevant documentation and example code. It was also expressed during the interview that further transparency in how the API should be used could be achieved. One example mentioned of how this could be achieved is by improving the expressiveness regarding which API functions are supported on which hardware types. These facts support that the law of conservation of familiarity is true for APIs. 

\smallskip \noindent
\textbf{Continuing Growth  } 
Large parts of the changes between the versions were strictly additions of new functional content. 4 new modules were added and significant additions of new functionality were added to the modules which were re-designed from version 1.4. The interviewee also made it clear that increasing the functionality was one of the main goals with the 2.0 update. This also ties in with the ambition of controlling the way that the API is used, as mentioned previously. It was also mentioned that the case company had received feedback from the API users that more frequent updates to the functional content was desirable, even though this may require them to update their application code. We therefore conclude that the law of continuing growth applies to APIs. 

\smallskip \noindent
\textbf{Declining Quality  } 
The interviews established that a groomative motive was not the primary reason for implementing any change. The changes to the example code and the documentation, as well as the re-designed modules are examples of these, where the main motive behind the change was to either prevent unwanted usage or to increase the functional content. These changes did, however, also increase the quality and were a substantial part of the update. Our analysis also shows that changes related to quality are bound to happen, as other types of changes often incorporate quality related aspects. We therefore settle that the law of declining quality applies to APIs. 

\smallskip \noindent
\textbf{Feedback System  } 
One of the future goals of improvement of the case company is to better include the API users and end-users of the applications in their feedback loop. Currently, only the API users are included in this feedback loop and the API architect expressed the desire to also include the end-users. The reasoning for this was to increase the quality, and to be able to deliver content which is useful for the users and which leads to good applications being developed. Prior to version 2.0 being released, an example of how the API users were included in the feedback loop was when they implemented functionality related to sound, despite the fact there was no interface for this.  The experiences of this API user, were later considered when developing the axsound module. One benefit of having a more structured feedback loop, would be that the API developers would have greater awareness of potential errors in the implementation of the API. Another ambition which was mentioned, was to bring scientific theories and best practices from academia into consideration when developing the API. This would aim to complement the current strategy which is largely based around the expertise and experiences of the API architects. Based on these factors and clearly expressed ambitions, we conclude that the law of feedback system is true for APIs. 



\subsection{RQ3 Results}
\noindent
RQ3: \textbf{To what extent can we reverse engineer API change decisions?}
\smallskip

After cross-examining our initial analysis with the interviewee's responses, we found that 85\% of our main type predictions matched the actual motive of the change and that 85\% of our secondary type predictions were correct. The kappa value \cite{cohen1968weighted} for the predictions was 0.812, which shows that there is a high level of agreement between the predictions and the change decisions. 

The changes related to functionality being added, modified (deprecated) or removed were predicted with a 100\% accuracy. These changes were deemed the most significant by the interviewee, and it was expressed during the interview that the these types of changes were the main driving factor behind the development of the new version. On the contrary, three out of five changes which were unrelated to functionality were correctly predicted. The two changes which were not predicted correctly were inaccurate because the main type was confused with the secondary type. This shows that, although the prediction was incorrect, the general reasoning was correct. The changes which had no secondary type were all predicted correctly, which further shows that changes with several types can be diffuse. 




\newpage
\section{Discussion} \label{discussion}
In this section, we will, based on the results of our study, answer the research questions and discuss the implications of our work, both for academia and practice. 

\newpage
\subsection{RQ1 Answer}  


Our results show that the major driving force for change in APIs is the push (!!!reword) for functionality. The classification of the types of software evolution and software maintenance showed that enhancive changes which either aimed to add brand-new (!!!reword) modules or adding functionality to existing modules were the most common. We also think that it is interesting to note that a majority of the changes which did not affect functionality, such as the updative changes, were spurred because of previous changes which were related to functionality. Following this line of thought, the hunger (!!!reword?) for functionality can be seen as a catalyst for other driving forces to occur (!!!reword). The view of considering functionality to be a major driver for change is supported by the analysis with Lehman's laws. In the law of Continuing Change, Lehman concludes that ``an E-type system must be continually adapted or it becomes progressively less satisfactory". The results of our work supports this view, as the changes did not only add functionality, but it was also found that the application developers most major concern were updates to functionality. 

In relation to this, previous work has identified that refactorings make up a substantial part of the changes APIs go through (!!!FIND PAPERS TO CITE HERE). These results are not in line with ours, since our results show that groomative changes are uncommon and that changes related to quality are not primary drivers of change and that they rather are ripple-effects of changes to functionality.  


Our results found that seven out of eight of Lehman's laws do apply to API evolution. The law of Conservation of Organisational Stability was found not to apply, since changes to APIs are often discouraged (!!!reword) by the fear that it will disrupt the applications using the API. This inertia to change in API evolution is supported by other research, which also conclude that the negative effect that changes to APIs may have is a major factor to be considered \cite{google_talk, henning2007api, mcdonnell2013empirical, robbes2012developers}. 

Based on our results, we form the conclusion that the hunger (reword) for functionality and the fear (reword) of changing are two opposing forces that cause updates to APIs to be infrequent. In the evolution of APIs, the negative effects of changes are greater than in other types of systems, which causes the the law of Conservation of Organisational Stability to not apply (!!!reword). This occurring has been considered by Lehman, as he noted that ``the laws are not immutable, since they arise from the habits and practices of humans" \cite{lehman1980programs}. The underlying reason for this is that the laws are influenced by conscious thought processes, based on human understanding \cite{lehman1980understanding}, which in the case of APIs is the conscious decision to limit updates as much as possible. 











\subsection{RQ2 Answer}
RQ2: How reverse engineer?


%1.1 Give a clear answer to the RQ. (Reject null / alternative)




%1.2 Point to results
%      -Bring up the most interesting/distinct trends










%1.3 Compare to literature (i.e. relate to previous work)
 %      -Do our results agree with prev. work?





\subsection{Implications for Academia} 
Reverse engineering/types: 
       Since we were able to correctly analyse which types they were, it should encourage academia to do more studies which reverse engineer theories etc. 

Laws:
       Some laws don't apply. Consider inverting the law of org stab for APIs
       Since motives are reverse engineerable, it should encourage more ppl to do similar studies

%       -How will our study help other researchers?
%       -How are the results valuable?



\subsection{Implications for Practitioners}
%       -How will our study help Axis? (More important)
The laws therefore form an environment within which the effectiveness of programming methodologies and management strategies and techniques can be evaluated, a backdrop against which better methodologies and techniques can be developed. [1980programs]

The main thing will be:
1. Our results found that feedback loop is, a) very importnat and b) the main thing that Axis wants to improve
2. Relate to Swanson/Chapin saying the types help to budget/plan and facilitate communication between stakeholders
       [quotes re. budget/plan]:

   ``Managers involved in software evolution and software maintenance have great difficulty in
   defining, justifying, budgeting, staffing, supervising, accounting for, marshalling resources
   for, and assessing the work when coarse non-objective measures are used [4]. Things not
   appropriately named are often undervalued and treated as miscellaneous or trivial, since
   communication about them is made more cumbersome.'' %Chapin

       [quotes re. communication/stakeholders]:
       ``management must be thoroughly fami-liar with the organizational conventions and practices
       involved, in order to make intelligent decisions.'' //Swanson
       
       ``provide a realistic and practical classification to facilitate communication about, and the
       management of, software evolution and maintenance among researchers, practitioners, and their
       managers;'' //Chapin

%Whole bunch of Swanson stuff below.
% The implications for the management of software
% maintenance are several. First, insofar as maintenance
% is performed informally, i.e. in the absence of an
% established set of organizational conventions and prac-
% tices, the measurement of maintenance performance w i l l
% not be feasible. The establishment of a maintenance
% data base, a precondition to performance measurement,
% is not possible in the absense of organizational struc-
% ture. In informal situations, performance must be assessed informally.

% Secondly, in any given organization in which main-
% tenance performance is formally assessed, in terms of
% specific measures, management must be thoroughly fami-
% l i a r with the organizational conventions and practices
% involved, in order to make intelligent decisions. No
% single measure or set of measures w i l l i t s e l f reveal
% that maintenance is going "better" or "worse" than
% management has a right to expect or desire. Such a
% judgment must follow as a systemic inference from an
% analysis of the performance measurements, made in the
% context of f a m i l i a r i t y with the organizational struc-
% ture which made these measurements possible.

% Finally, in the absence of f a m i l i a r i t y with other,
% alternative organizational structures for performing
% maintenance, management w i l l be essentially unable to
% assess i t s own established structure. Nothing in the
% performance measurements made within the context of the
% established structure w i l l indicate the opportunity
% costs associated with this structure. Management must
% look outside, to the performance measurements and
% structures of other organizations, to assess what might
% reasonably be achieved through organizational change.

% In the context of a maintenance organizational
% structure and a particular set of data gathered in the
% performance of maintenance within this structure, i t
% is possible to derive some performance measures which
% should be appropriately "suggestive" to management.

% Measures of maintenance performance are
% not meaningful except within the context
% of the organizational structure(s) upon
% which they are based.


3. Suggest to Axis that they improve their feedback loop by using the types

Also suggest that they keep evolving the API with reference to the laws



Implications for Practice tips: 
       3. Each implications for practice section should include descriptions of 
       a) problematic issue(s) being addressed, 
       b) the specific audience(s) to which implications are addressed, 
       c) a small number of recommendations about what the audience should/could/should not do based on the research findings, 
       d) an expected outcome of carrying out recommendation(s), and 
       e) some specific illustrations of what carrying out the recommendations might look like, perhaps in narrative form.

\url{https://www.princeton.edu/futureofchildren/publications/journals/article/index.xml?journalid=46&articleid=212&sectionid=1379}

--------------------------------------------------------------------------

























\section{Conclusion} \label{conclusion}
ATTN: This section has not been started. 

1. Summary of our results/discussion i.e. short conclusion


2. Future work:
       a) Eco-system (rel. to feedback loop law and Chapin/Swanson communication to stakeholders)
       b) Business motives instead of evolution theories
       c) A study which analyses how the API applications change when new versions are introduced (rel. to controlling the behaviour etc.)

       In-depth study on the laws or a specific law? Maybe less interesting.







\section{Acknowledgements}
We would like to thank Axis and that project at GU. 

\bibliographystyle{abbrv}
\bibliography{bib} 






\end{document}










