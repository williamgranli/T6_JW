

\documentclass{sig-alternate}
\usepackage{blindtext}
\usepackage[english]{babel}

%
\usepackage{array}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{booktabs} 


%Used for \textsubscript
\usepackage{fixltx2e}



\begin{document}


\conferenceinfo{14th IWPSE} {'15 Bergamo, Italy}
\CopyrightYear{2015}

\crdata{1-23456-78-9/01/23}


\title{The Types and Driving Forces of Modifications in the Evolution of an API}


\numberofauthors{2} 

\author{
% 1st. author
\alignauthor
John Burchell\\
%       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{john.a.burchell@gmail.com}
% 2nd. author
\alignauthor
William Granli\\
%       \affaddr{Computer Science and Engineering}\\
       \affaddr{University of Gothenburg}\\
       \email{william.granli@gmail.com}
%\and
% 3rd. author
%\alignauthor Imed Hammouda\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
% 4th 
%\alignauthor Eric Knauss\titlenote{Co-author}\\
%       \affaddr{Computer Science and Engineering}\\
%       \affaddr{University of Gothenburg}\\
%       \email{imed.hammouda@gu.se}
}

\maketitle

\begin{abstract}


\textbf{Background  } %Give a feeling of the need of this study, answer why Axis needs what is in the Objective (+Context)
The driving forces of modifications to APIs have been investigated before, however, platform APIs are, until now, unexplored. Previous studies have not considered APIs from the perspective of well-established software evolution theories. 

\smallskip \noindent
\textbf{Objective  } %Done
In this study, we explore how companies actively evolve their APIs and 'how APIs evolve from a passive point of view'. We also aim to evaluate to what extent we are able to reverse engineer these evolutionary change decisions. The goal is to study these factors by evaluating them against existing software evolution theories. 

\smallskip \noindent
\textbf{Method  } %Done
This case study was conducted by analysing the changes between two versions of a platform API and its documentation. The results were analysed from a qualitative and investigative perspective, and were then reviewed and validated with the architects of the API. 

\smallskip \noindent
\textbf{Results  } %Done
We identified thirteen major changes which were introduced in the new version of the API. We concluded that the dominant driving force of the API evolution is demand for new functionality and that change decisions, to a large extent, are reverse engineerable. We also found that long-established software evolution laws were largely applicable to APIs. 

\smallskip \noindent
\textbf{Conclusion  }
This study has provided valuable insight into the evolution of platform APIs. The qualitative analysis can help other companies to improve their API maintenance process. The successful attempt to reverse engineer the change decisions should encourage similar studies to be conducted. The investigation of Lehman's laws show that APIs cannot be generalised and be compared to any type of system. 



\end{abstract}

\category{D.2.7}{Software Engineering}{Distribution, Maintenance, Enhancement}[Restructuring, reverse engineering, and re-engineering]
\keywords{API Design, Software Evolution, Software Maintenance}







\section{Introduction} \label{introduction}
%API Design (and a little bit of ecosystems and a bit of problem statement)
As the software industry and the open-source movement continue to grow, the number of public APIs is steadily increasing. APIs can improve the development speed \cite{stylos2006comparing}, contribute to higher quality software \cite{stylos2006comparing} and increase the reusability of software \cite{afonso2012evaluating}. There is a consensus in that modifications to APIs could negatively impact the users of the API \cite{google_talk, mcdonnell2013empirical, robbes2012developers, henning2007api}. The main reason for this is that it requires the API users to update the application code, thus causing a disruption in the application's software ecosystem \cite{messerschmitt2005software}. Refactoring is the most common change that APIs undergo \cite{dig2005role, xing2006refactoring}. 
%Software Evolution 
In the discipline of software evolution, such updates to software are studied from an evolutionary standpoint. Software can be updated for different reasons and these motives can be grouped into corrective, adaptive, perfective and preventive changes \cite{lientz1980software}. 

%Gap in Literature
Studies that explore the intent behind API modifications exist \cite{hou2011exploring}. The area of programming language APIs is well-explored \cite{hou2011exploring, shi2011empirical}, but few studies that explore platform APIs exist \cite{robbes2012developers}. To the best of our knowledge, no studies that explore API evolution have until now been performed on embedded platform APIs. 

%switch places between ^ and v

%Purpose
Modifications to deployed APIs may negatively impact its users. It is therefore important to investigate why these changes occur. Understanding the motives behind the changes could help API designers to  prevent potential future changes to their APIs. Before industry can safely include such information in their feedback loop, we must critically assess to what degree we can reverse engineer such motives. 

%Method %wrong tense %include RQs in here %include clear contribution (to johanna)
In order to achieve this, an exploratory case study will be undertaken to investigate the underlying motives behind changes to APIs. Empirical analysis of the changes between two major versions of an API will be undertaken, following which, an interview with the architects will be used to validate the findings of our analysis. 

%Can't find a place for this - it's repeated in the Purpose
%Reverse engineering design decisions is a challenging yet interesting problem. The better we can understand why changes occur and what problems they are trying to solve, the better we can design around these problems to avoid them cropping up in the future.


\subsection{Research Questions} \label{rqs}
\begin{description}
\item[\textbf{RQ1}] How do companies actively drive API evolution?
\item[\textbf{RQ2}] To what extent can we reverse engineer API change decisions?
\item[\textbf{RQ3}] How do APIs ``passively'' evolve?


\end{description}

%Structure of the paper
The sections following the Introduction are structured as follows: In Section \ref{background}, we present the background and previously published work that is related to our study. Section \ref{case_company_description} describes the case company and the API which was studied. A description of our methodology is introduced in Section \ref{methodology}. In Section \ref{results}, the results of our study are presented and in Section \ref{discussion}, we discuss the findings of our study. In Section \ref{conclusion} we propose the potential impact of our work and give suggestions for future work that builds on our research. 

\section{Background} \label{background}
This section will introduce the fields of API design and software evolution, and provide a review of studies that are directly related to our study. Follow that, we will introduce the company and API examined in this study. 


\subsection{API Design} \label{api_design}
API design is notoriously difficult, as a myriad of design and performance decisions must be taken into consideration when creating APIs \cite{afonso2012evaluating, bloch2008effective, stylos2006comparing}.

Examples of such design decisions include how to structure an object's constructor parameters or if the API should display errors at compilation or at runtime \cite{stylos2006comparing}. More trivial design problems, such as assigning names to API features or correctly naming user-defined types, can have a significant impact on the usability of an API \cite{shi2011empirical}. When facing such design challenges, the following four factors are important to consider: a) The API must be understandable through good documentation, b) the API must not be overly abstract, c) the API must be reusable and d) the API must be easy to learn \cite{shi2011empirical}. One of the most important qualities in an API is that the intent of the API must be clear to the user \cite{stylos2006comparing, shi2011empirical}. The design decisions reached during development of an API will affect the overall usability of the API. Measuring such an effect can be done by investigating the twelve cognitive dimensions that are impacted by interactions between the API and its users \cite{clarke2004measuring}. 


\subsection{Software Evolution} \label{software_evolution}
%%Categories of maintenance and types of maintenance
Software evolution is a field that studies the application of software maintenance activities, changes in software processes and the resulting, evolved versions of the software. The concept of software maintenance has existed since the 1960s when it was first introduced to the software development community \cite{lientz1980software}. A set of four categories describing different types of software maintenance \cite{lientz1980software} became the basis upon which twelve new types were developed \cite{chapin2001types}. The twelve types of software evolution and software maintenance, as seen in Table \ref{table:expl_types}, describe a software evolution activity that relates to one of three particular areas; the code, the software and the customer-experienced functionality. 

%%Lehman's laws (!!!improve later)
Software evolution theory suggests that changes to software must obey one of eight laws \cite{lehman1980programs}. The laws, known as Lehman's laws, are: 1) Continuing Change, 2) Increasing Complexity, 3) Self Regulation, 4) Conservation of Organisational Stability, 5) Conservation of Familiarity, 6) Continuing Growth, 7) Declining Quality and 8) Feedback System. The laws are said to only apply to E-type systems, which are programs that solve problems or address applications in the real world.     

\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Type}                              & \textbf{Explanation}    \\ \midrule
              Corrective    & [Explanation]                      \\ \hline
              Reductive     & [Explanation]                     \\ \hline
              Adaptive      & [Explanation]                      \\ \hline
              Performance   & [Explanation]                     \\ \hline
              Preventive    & [Explanation]                      \\ \hline
              Groomative    & [Explanation]                      \\ \hline
              Updative      & [Explanation]                     \\ \hline
              Reformative   & [Explanation]                     \\ \hline
              Evaluative    & [Explanation]                     \\ \hline
              Consultive    & [Explanation]                     \\ \hline
              Training      & [Explanation]                     \\ 

              \bottomrule

       \end{tabular}
       \caption{Explanation of Types of Software Maintenance}
       \label{table:expl_types}
\end{table}




\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Law}                              & \textbf{Explanation}    \\ \midrule
              Continuing Change                         & [Explanation]                      \\ \hline
              Increasing Complexity                     & [Explanation]                     \\ \hline
              Self Regulation                           & [Explanation]                      \\ \hline
              Conservation of Organisational Stability  & [Explanation]                     \\ \hline
              Conservation of Familiarity               & [Explanation]                      \\ \hline
              Continuing Growth                         & [Explanation]                      \\ \hline
              Declining Quality                         & [Explanation]                     \\ \hline
              Feedback System                           & [Explanation]                      \\ 

              \bottomrule

       \end{tabular}
       \caption{Explanation of Lehman's Laws}
       \label{table:expl_laws}
\end{table}


\subsection{API Evolution} \label{related_work}
The analysis of APIs in the context of software evolution has primarily focused on APIs that are part of large programming languages, such as Java \cite{hou2011exploring, shi2011empirical} and Smalltalk \cite{robbes2012developers}. Attempts to uncover the intents behind the changes made in the AWT and Swing Java libraries have also been undertaken \cite{hou2011exploring}, leading to suggestions that the use of a strong architecture is vital for ensuring the successful evolution of an API \cite{hou2011exploring}.

Investigations of three frameworks and one library indicated that 80\% of refactoring changes to APIs negatively affected existing applications \cite{dig2005role}. The changes, sometimes referred to as ripple effects \cite{robbes2012developers} indicate that negative effects of changes can propagate throughout a software ecosystem. It was found that 14\% of non-trivial API deprecations caused errors in at least one project, with the worst case of 79 projects being affected \cite{robbes2012developers}.

%%Possibly add a paragraph here to motivate the gap more



\subsection{Case Company Description} \label{case_company_description}
The case company is a company operating in the domain of video surveillance. The company's headquarters are located in Lund, Sweden, with offices in 49 countries worldwide. The company is the global market leader in the markets of network cameras and video encoders. They develop embedded software for security cameras. The cameras are designed to be accessible through APIs that are developed and maintained by the company. 

The API analysed in this study is written in the programming language C and has been deployed for several years. It was recently updated from version 1.4 to version 2.0, which is the current active version. The changes between these two versions is what has been analysed in this study. Between the release of version 1.0 and 1.4, no functionality was added, as it only added additional build options for other hardware platforms. Prior to version 1.4 being released, updates were only made to include additional built options and did not include any additional functionality. The API is used by company partners, which are companies who develop applications for the cameras. These applications are, in turn, used by the end-users of the cameras. The API is developed for a wide range of camera types that offer different functionality and are used for different purposes. 




\section{Methodology} \label{methodology}
%Intro and summary
This study has been conducted using the case study methodology \cite{runeson2009guidelines}. The goal of the study was twofold. Firstly, the aim was to empirically explore the motives behind changes to APIs and secondly, to validate the results' level of correctness by comparing our findings with the case company's explanation of their motives. Our research can be classified as an embedded case study \cite{yin2013case}, since both the API code and API documentation have been used as units of analysis. 

%Reasons for choosing case study
The reason the selected methodology was used is that it is essential to study the phenomenon of API change in its natural context. The applicability of case studies in such scenarios is supported by existing literature \cite{benbasat1987case, runeson2009guidelines, yin2013case, robson2002real}. An alternative approach that was considered was design research, but if a prototype API was to be used instead of one which is tried and tested in an industry setting, the study would lack real-life context \cite{runeson2009guidelines}. An additional motivation for why the case study approach was used is that there is little existing research conducted in the area of motives behind API change and that input from the industry is vital to the success of the research, especially to be able to answer \textbf{RQ2}. 

The study was conducted in two major phases \cite{andersson2007spiral}. The aim of the first phase was to generate hyptheses and to formulate clear research questions. This was achieved by using a data-driven approach to analysing the code and documentation. The second phase included analysis of the interviews, during which we aimed to confirm the hypotheses that were formulated in the first phsae. Both phases were performed iteratively. This created the opportunity to improve the data analysis as the study progressed, as well as allowing us to adapt to possible changes in direction, due to the hypothesis generating approach of the first phase. 

The process used for examining the code and documentation was inspired by grounded theory analysis \cite{seaman1999qualitative}, as it is recommended for hypothesis generating studies \cite{runeson2009guidelines, seaman1999qualitative}. 






\subsection{Data Collection} \label{data_collection}  
%Intro to code inspection
The data were collected primarily through inspections of the source code and the analysis of accompanying documentation. The source code was comprised of the two API versions previously mentioned. Each version of the API had its own respective documentation, including example code, a library description and a basic development manual. 

%How the initial inspection was performed
The API code was inspected sequentially, starting with version 1.4. Both versions of the API underwent the same inspection. This involved extracting method signatures, enums, structs, typedefs and macros, which were subsequently stored in spreadsheets. The extraction involved a lot of manual work, but Git's \cite{git} diff command was used to identify changes in files which exist in both versions. After a change was identified in the code, a description of the corresponding change in the documentation was added to the spreadsheet. The module and file in which the change was identified was then logged together with an ID and a description of the change. The data collection from code and documentation was performed independently by both John Burchell and William Granli, to reduce the risk of human errors affecting the results. If the data collected by each researcher differed, the cause of the discrepancy was investigated and resolved. 

%Purpose of the interview
After the initial source code inspection and preliminary analysis had been performed, an interview was conducted. The main purpose of the interview was to validate our findings from the code inspection with the API architect. The interview also served the purpose of providing additional insight into what drove the evolution of the API, by complementing what was found from the code inspection. The final reason for interviewing the API architect was to gather information about the API users and how their decisions, needs and requirements have affected the development of the API. 

%Structure of the interview
The interview was conducted using a semi-structured approach \cite{robson2002real}. Structure to the interview was provided by organising it around the software evolution theories \cite{chapin2001types} \cite{lehman1980programs}. Investigative and open-ended questions related to each category and law were asked to provide a basis for comparison between the answers and our initial analysis. The interviewee was encouraged to speak freely, even if it required a change in direction or topic. This was allowed in order to fulfil our exploratory goal of the study. 




\subsection{Data Analysis} \label{data_analysis}

%Codes
To analyse the data each change identified in the spreadsheet was coded based on which module the change occurred in and two other characteristics: a) if the change added, removed or modified functionality, and b) if the change was a cosmetic change or not.
%Concepts
Grouping the codes by module allowed us to form general concepts of change. However, changes that affected the whole API were categorised on their own.
%Categories
These concepts were then grouped into categories based on common patterns between the concepts.
%Theory
These categories were then used to identify the most notable trends in the evolution of the API. These trends were later used as a basis for discussion during the interview.

%RQ1
The trends identified previously were then classified according to the software maintenance types \cite{chapin2001types}. The process followed the decision tree used for classifying the types of software evolution and software maintenance \cite{chapin2001types}. Each of the previously identified trends were given a main type of maintenance and, if appropriate, a secondary type. This material, as well as the results of the interview, were then used as the basis for answering \textbf{RQ1}.

%RQ2
To allow us to answer \textbf{RQ2}, we compared our analysis and interpretation of the trends identified prior, against what was expressed by the API architect, during the interview. Success was determined by comparing the inter-rater reliability, by performing calculating Cohen's Kappa gathered data. 

%RQ3
The analysis of the changes and trends, combined with the information gathered from the interview, allowed us to answer \textbf{RQ3} by determining if Lehman's Laws apply to the changes made to the API. 




\subsection{Validity Threats} \label{validity_threats} %Review 1 or 2 more times (John first)
In this section we discuss possible threats to construct validity, internal validity, external validity and reliability \cite{runeson2009guidelines}.

\smallskip \noindent
\textbf{Construct validity  } Threats to construct validity have largely been mitigated by structuring the results of the study around already established and accepted software evolution theories \cite{chapin2001types, lehman1980programs}. Due to restricted access to the company's source code, we were not able to include versions prior to version 1.4 in our analysis. This means that the evolution of the API was studied during a rather short period of its lifetime. It was also not possible to analyse the implementation of the API, something which might have contributed to more accurate predictions of the motives behind the changes. We consider these factors to be the remaining threats to construct validity. 

\smallskip \noindent
\textbf{Internal validity  } Limitations related to internal validity have been acknowledged by analysing the code and documentation jointly. This has contributed to triangulating the results and discovering possible inconsistencies. Further triangulation of the results was performed by interviewing the API architect. Business-related factors might have had an impact on the evolution of the API, and these were not closely investigated. This was not in the scope of the study and would best be investigated in a study complementary to ours. The study revealed that the API users were significant to the evolution of the API. Since API users were not interviewed, it might be an affecting factor which was left unexplored. 

\smallskip \noindent
\textbf{External validity  } The results of our study should be highly generalisable to similar studies conducted on any type of APIs, since the evolution of the API has largely been driven by software-related factors. Our study can especially be compared to similar studies conducted on platform or embedded APIs. Further comparability to our study is offered through how the results are structured around established software evolution theories. 

\smallskip \noindent
\textbf{Reliability  } Potential threats to the reliability of our study have, to a great extent, been reduced by conducting the study according to an accredited guide to case studies \cite{runeson2009guidelines}. In addition to that, strategies from additional well-established papers \cite{andersson2007spiral, seaman1999qualitative, robson2002real} have been used to increase the trustworthiness of the data gathering and data analysis. The analysis was based around well-defined theories that are cemented in academia, to further increase the reproducibility of the study. The semi-structured nature of the interview, might threaten the reproducibility; however, large parts of it were structured around existing theories. 




\section{Results} \label{results} 
This section will present the findings of our study. The results related to \textbf{RQ1} and \textbf{RQ2} are introduced in Section \ref{results_rq1}, and the results of \textbf{RQ3} are presented in Section \ref{results_RQ3}


\subsection{RQ1 Results} \label{results_rq1}

The majority of changes between version 1.4 and version 2.0 have been additions to functionality of the API. Such additions include added functionality to mechanically and digitally control the camera, to utilise additional storage devices, to allow serial connectivity and to allow audio analysis on the cameras. Pure additions to the API did not have any secondary types of change attributed to them.

Many of the changes found many deprecations which were later re-implemented as new modules. We have grouped these kinds of changes into a single type instead of two. Such examples include the deprecation and re-implementation of an event system, dynamic web page generation and configuration utilities. These kinds of changes often had a secondary type of change that accompanied the primary type of change.

The remainder of the changes were defined as general trends. These changes were not individual, but were instead larger changes that effected the whole API. Such examples include a shift towards using interfaces to access features, improved maintainability, a different error-handling approach and the inclusion of additional 3\textit{rd} party libraries. With the exception of 3\textit{rd} party libraries, the general trends have secondary changes which help to categories what effect the changes had on the API.

All of the identified changes have been given a type based the nature of the change according to the Types of Software Evolution and Software Maintenance decision tree \cite{chapin2001types}. In total, thirteen unique changes were found.

\smallskip \noindent
\textbf{Enhancive  }
%Define how we identified the change type
Additions or re-implementations of functionality are defined to be enhancive changes. In addition to this, we have included deprecations that have then been re-implemented to also be enhancive.
%Some Data and little explanation
53.8\% of the identified changes were given the type of enhancive. The majority of which were additions of new functionality to the API. Two examples of added functionality are the addition of camera movement module and an audio analysis module. One example of a deprecation that was re-implemented is the event system.
%Conclusion
Given that over half of the changes were identified to be enhancive, we conclude that the APIs evolution primary type of change was enhancive. 

\smallskip \noindent
\textbf{Corrective  }
%Define what kinds of changes these are
Corrective changes are identified as types of change that fix broken functionality.
%Data and explanation
No corrective changes were identified between v1.0 and v2.0. There are two main reasons that we did not find any changes of this type. Firstly, the majority of changes were additions or re-implementations of functionality. This meant that most of the existing code was either removed, replaced or deprecated, resulting in little to no obvious fixes. Secondly, we only had access to the public facing API and not the implementation itself. We therefore could not inspect the inner workings of the functionality that has remained between versions to determine if any corrective change took place.
%Conclusion
We therefore conclude that the evolution of the API was not driven by corrective changes.
\smallskip \noindent
\textbf{Reductive  }
%Definition
Reductive changes are defined as changes that remove or reduce functionality. This is distinctive from a deprecation as reductive types of change remove functionality completely.
%Data & Explanation
Only a single reductive type of change was identified. This reductive change removed functionality that provided the ability to buffer individual images for closer analysis by a user. Given that it is more common to refactor APIs and not remove functionality \cite{dig2005role, xing2006refactoring} this was a surprising result. 
%Don't know if I should discuss the finding in this much depth here?
%If OK - Talk more about the business side of things, and how we couldn't identify this change ourselves
It was revealed during the interview that the functionality was removed because the case company no longer wished to support this feature, due to hardware constraints. 
%Conclusion
As this was the only reductive change found, we conclude that the evolution of the API was not primarily driven by reductive changes.

\smallskip \noindent
\textbf{Adaptive  }
%Introduction and definition
Adaptive changes are defined to be changes which involve changes to technology or resources used. 
%Data and examples
A single change was identified as being adaptive; the inclusion of new 3\textit{rd} part libraries. Glib existed in version 1.4 of the API its use was increased in version 2.0. Furthermore, other libraries were added for audio and data communication. This type of change made up 7.7\% of the total changes, however it had a broader impact than other individual changes.
%Conclusion 
The evolution of the API has not been primarily driven by adaptive changes. However, more information, possibly in the form of another study, would be required to fully conclude if these types of changes have a greater impact upon the evolution of an API.

\smallskip \noindent
\textbf{Performance  }
%Define
Performance changes are defined to be types of change that intentionally alter system performance.
%Data and examples
No performance types of change were identified in the API. Only having access to the public API and not the implementation meant that we were unable search for performance changes in existing code between the versions. There was no indication from the documentation nor the interview that any change had been performed with the intent of increasing system performance. 
%Conclusion
As such, we conclude that the evolution of the API was not driven by performance changes. A proper benchmark could be performed on sample programs written with both versions of the API to test overall performance. However, this is outside the scope of our study.

\smallskip \noindent
\textbf{Preventive  }
%Define
Preventive changes are defined to be changes that attempt to avoid future maintenance. This should not be confused with changes that attempt to make the current state of the system more maintainable.
%Data and examples
15.8\% of the changes were given the type of Preventive. A new error handling system was one of these changes. It is unclear from version 1.4 what error handling was in place, however, version 2.0 saw the addition of specific error handling modules and functions. According to the interview, the error handling change coincided with the inclusion of more Glib features, which the new error handling system uses. The redesign of the system to use more interfaces was also deemed as a preventive change. Using interfaces to access modules helps to make them more maintainable and more easily extendable, which is a good example of a preventive change.
%Concusion
Preventive types of change appear to drive the evolution of an API more strongly than other types of changes do. This could be due to the fact that as the API grows, the need for higher maintenance also increase, a fact that also seems to be supported by Lehman's laws.

\smallskip \noindent
\textbf{Groomative  }
%Define
Groomative changes are defined to be changes that aim to make the code more maintainable immediately. This should not be confused with preventive changes.
%Data and examples
While none of the change identified were primarily groomative changes, three of them were secondarily categorised as being groomative. This seems to indicate that the groomative nature of a change is often a bonus of other kinds of changes. The move towards using interfaces can be seen as an example of this. While the primary motive of change was to make the API more maintainable in the future, making the API more maintainable immediately was also a reason for the change.
%Conclusion
While not a primary factor for any of the changes, groomative types of change should still be viewed as important for API evolution.

\smallskip \noindent
\textbf{Updative  }
%Define
Updative changes are defined to be changes to documentation and are not changes that affect functionality in any way. We also considered updates to example code and other training material to be Updative types of change.
%Data and example
A single change was determined to be Updative. This change was the updating of the API documentation to match the new API. The updates included a new API specification, deprecation list and the inclusion of the new features and libraries.
%Conclusion
Updative changes have very little impact on the functionality of the API yet they are still important changes for the usability of the API \cite{shi2011empirical}. We therefore conclude that the evolution of an API is not driven by updative changes.

\smallskip \noindent
\textbf{Reformative  }
%Define
Reformative changes are defined to be changes that update the documentation to the stakeholders needs.
%Data and Example
One reformative change was identified between version 1.4 and version 2.0 which involved a re-write of the existing example programs. The aim of the re-write was to update the examples to take advantage of the new functionality in the API while simultaneously showing how the modules interact and presenting a standard for how to use the API correctly.
%Conclusion
The reformative change that was found indicates therefore that updating documentation and example code is to some extent import for API evolution.

\smallskip \noindent
\textbf{Evaluative, Consultive and Training  }
%Define
Evaluative, Consultive and Training are all types of activities, rather than changes that a system can undergo. Evaluative activities are defined as activities such as auditing or evaluating the software. Similarly, consultive activities involve consultations with customers about the software. Finally, Training activities involve training for customers and users of the software.
%Data and example
None of the aforementioned activities occurred as part of the APIs evolution as these activities do not play a role in API evolution. This is supported by the fact none of the activities were identified for the changes.
%Conclusion
We can therefore conclude that these change types are not important for API evolution.

\subsubsection{Summary}

\noindent
\textbf{Functionality is a prime driver of API evolution  }  %Reviewed by JW
Overwhelmingly, the primary driving factor behind API evolution was the desire for new API functionality. We found that a vast majority of the changes either added functionality or were a direct consequence of increased functionality. The main driver for these changes was the pressure from API users, but pressure from the case company developers who utilise the API also contributed. This focus upon functionality was also emphasised partially due to a business goal. The more features the API provides allows for more applications to be created for the cameras. This has a domino effect of increasing the appeal and value of the products the case company produces.

\smallskip \noindent 
\textbf{Maintainability does not drive change  }  %Reviewed by JW
While maintainability is important, it is not a primary driving factor for change. We found that where changes that effected maintainability, functionality had also been added or modified. Of the changes identified, none were considered to be primarily groomative. Groomative motives were only found to be secondary, and were never the main motive for a change. Changes to the example code are an example of this. The example code was updated purely to reflect the changes in functionality and not as a groomative effort. 

\smallskip \noindent
\textbf{Standardising application development  } %Reviewed by JW%Reviewed by JW
Supporting users of the API in creating correct and robust applications is a very important evolution factor for the case company. Changes between the versions introduced improvements to error handling, the example code and the way in which the API utilises interfaces. This, coupled with removal of unwanted functionality and unsafe operations, has allowed the API to grow and become much more user-friendly. As mentioned previously, this could increase the amount of applications being created for the camera and as a consequence, could potentially increase the value of them.

\smallskip \noindent
\textbf{Removing functionality  } %Reviewed by JW
Previous literature has suggested that deprecating functionality is the most common technique used to remove support for specific functionality. Removals are only suggested in specific circumstances. The successful removal of the burst function seems to indicate that under the correct circumstances, removing specific functionality is an alternative that should be considered. The case company removed this function from the API, after an internal review found that the potential negative effect the removal could have, would be less impactful than further maintenance of the function. We therefore recommend to remove functionality of an API if the effect of the removal has been thoroughly investigated and that the removals happen incrementally.

\smallskip \noindent
\textbf{Documentation does not drive change  } %Reviewed by JW
The intent to update example code and documentation was described by the interviewee to be an important change between version 1.4 and 2.0. While important for the APIs usability, it was not a driving factor of change itself. The changes to the APIs' design and functionality caused the need to update the documentation and example code.

\smallskip \noindent
\textbf{Hardware is not a driving factor  } %Reviewed by JW
Our initial expectations included the view that changes to hardware would be one of the strongest driving factors of API evolution. One example could be if new cameras are created or new hardware is added to an existing camera, which would require updates to the API to allow use of the new features. However, after analysing the changes and from the information gathered in the interview, we discovered that hardware has played a minimal role in the evolution of the API. 

\subsection{RQ2 Results}

% After cross-examining our results with the interviewee and their responses, we found that 78\% of our main category predictions matched the actual motive of the changes and that 78\% of our secondary categorisations matched the actual motives. 





\noindent
\textbf{Functionality is reverse engineerable  } %Reviewed by JW
All changes whose main motive was to either add or remove functionality were accurately predicted. These changes were the most significant and it was expressed during the interview that these types of changes were the main driving factors behind the development of the new version. In summary, eleven out of a total of thirteen changes were correctly predicted. It is also interesting to note that all changes which were not assigned any sub-category were correctly predicted. This supports the fact that such changes have a clearer intent and are perhaps more well-defined.

\smallskip \noindent
\textbf{Design changes are reverse engineerable to some extent  }  %Reviewed by JW
Three out of five changes which did not add functionality, but rather were introduced to reduce complexity and increase quality, were correctly predicted. The two changes which were incorrectly predicted were inaccurate because the main motivation was confused with the secondary intent. This shows that, although the prediction was incorrect, the general reasoning was correct. Our predictions were accurate enough to allow us to form a reliable conclusion which provided valuable discussion with the case company. 


\subsection{RQ3 Results} \label{results_RQ3} 
\noindent
RQ3: \textbf{How do APIs ``passively'' evolve?}
\smallskip

The results related to \textbf{RQ3} are structured around each of Lehman's laws of software evolution \cite{lehman1980programs} and to what extent our findings show that the laws apply to platform APIs. A summary of our findings can be seen in Table \ref{table:lehman}. 


\begin{table}
       \centering
       \begin{tabular}[ht]{l|c}
              \toprule

              \textbf{Law}                              & \textbf{Applicability}    \\ \midrule
              Continuing Change                         & True                      \\ \hline
              Increasing Complexity                     & Kinda                     \\ \hline
              Self Regulation                           & True                      \\ \hline
              Conservation of Organisational Stability  & False                     \\ \hline
              Conservation of Familiarity               & True                      \\ \hline
              Continuing Growth                         & True                      \\ \hline
              Declining Quality                         & Kinda                     \\ \hline
              Feedback System                           & True                      \\ 

              \bottomrule

       \end{tabular}
       \caption{The applicability of Lehman's laws}
       \label{table:lehman}
\end{table}


\subsubsection{Lehman's Laws}

\smallskip \noindent
\textbf{Continuing Change} 
The case company described that including new functional content was one of the top priorities for the release of version 2.0. This is supported by the characteristic of the changes identified in this study. 4 of the 13 changes were additions of new modules, and additional functionality was also added to re-implemented modules. It was also mentioned that the API users had previously requested more frequent updates to the API, despite the drawbacks this could cause. One of the main reasons for continuously adapting the API is also to control the way API users use the API. Prior to version 2.0 being released, a number of API users used workarounds to implement applications which contained functionality which was not yet offered from the API. These applications were fully functional, but there existed no standard method of implementation. We therefore conclude that the law of continuing change holds for APIs. 

\smallskip \noindent
\textbf{Increasing Complexity} \label{sec:law2} 
A majority of the changes introduced in version 2.0 aimed to improve the structure and the way that the API was used. Many of these changes were related to the same design choices, which enforced a certain implementation style on the whole API. One example of this is the change to the interfaces which set a standard for the whole API. During the interview it was also concluded that consistency and following certain standards is an important factor to consider when designing APIs. It was also made clear that a contributing factor for changing certain parts of the API was to bring it into line with the new interface design. The interviewee mentioned that one way of achieving this was to follow guidelines or design best practices, but that the company currently did not make use of these. Even though the importance of maintaining the API in order to reduce complexity was stated, arguments which support that it is of lesser importance than releasing functional content was also presented. One example of where this is evident in the evolution of the API, is in the module that handles the video capturing and video stream. It was decided that this module would not be re-designed to conform with the new interface standard, as the changes to functionality in this module were very minor. Thus, the law of increasing complexity holds for APIs, but there is evidence that suggests that decreasing the complexity is not of the highest priority. 

\smallskip \noindent
\textbf{Self Regulation} \label{sec:law3} 
The release of version 1.4 did not include any changes related to the API interface. Version 1.0 through to 1.4 strictly added support for additional build target platforms. When comparing the changes introduced in version 2.0 to the ones in previous versions, it is clear that the growth of the API has gradually increased. During the interview it was also mentioned that the future plans for the API did not include any major changes and that only a few minor changes were planned in the near future. The future updates to the API will also be made incrementally and there will not be a big bang update similar to that of version 2.0. This supports that the law of self regulation applies to APIs, assuming that version 2.0 can be considered to be the peak of the normal distribution curve of the APIs growth. 

\smallskip \noindent
\textbf{Conservation of Organisational Stability} 
The changes to the API have been made very sporadically, where only two new versions have been released since the deployment of version 1.0. As mentioned in Section \ref{sec:law3}, the changes introduced in version 1.4 did not involve any changes to the existing API functions. Consequently, the only significant update to the API was made in the transition to version 2.0. The internal development of the API has also been made sporadically and there have been periods where the API has not been actively developed. This suggests that the law of conservation of organisational stability does not apply to APIs. 

\smallskip \noindent
\textbf{Conservation of Familiarity} 
The documentation that is included with the API was rigorously updated with the introduction of version 2.0. All functionality which was added or modified in version 2.0 was updated accordingly in the documentation. The same pattern can be seen for the example code, which went through major changes as a result of the changes to the API code. The case company's intent to control the way that their API is used also suggests that the knowledge of how to use the API is of importance, since if the API is used in too many different ways, it will be more difficult for the case company to have relevant documentation and example code. It was also expressed during the interview that further transparency in how the API should be used could be achieved. One example mentioned of how this could be achieved is by improving the expressiveness regarding which API functions are supported on which hardware types. These facts support that the law of conservation of familiarity is true for APIs. 

\smallskip \noindent
\textbf{Continuing Growth} 
Large parts of the changes between the versions were strictly additions of new functional content. 4 new modules were added and significant additions of new functionality were added to the modules which were re-designed from version 1.4. The interviewee also made it clear that increasing the functionality was one of the main goals with the 2.0 update. This also ties in with the ambition of controlling the way that the API is used, as mentioned previously. It was also mentioned that the case company had received feedback from the API users that more frequent updates to the functional content was desirable, even though this may require them to update their application code. We therefore conclude that the law of continuing growth applies to APIs. 

\smallskip \noindent
\textbf{Declining Quality} 
The interviews established that a groomative motive was not the primary reason for implementing any change. The changes to the example code and the documentation, as well as the re-designed modules are examples of these, where the main motive behind the change was to either prevent unwanted usage or to increase the functional content. These changes did, however, also increase the quality and were a substantial part of the update. A counterargument to this reasoning can be seen in the module which handles the video data and capturing, which was not changed between the versions, as mentioned in Section \ref{sec:law2}. We therefore settle that the law of declining quality can be applied to APIs, but that there is data that implies that reducing quality is not of high importance. 

\smallskip \noindent
\textbf{Feedback System} 
One of the future goals of improvement of the case company is to better include the API users and end-users of the applications in their feedback loop. Currently, only the API users are included in this feedback loop and the API architect expressed the desire to also include the end-users. The reasoning for this was to increase the quality, and to be able to deliver content which is useful for the users and which leads to good applications being developed. Prior to version 2.0 being released, an example of how the API users were included in the feedback loop was when they implemented functionality related to sound, despite the fact there was no interface for this.  The experiences of this API user, were later considered when developing the axsound module. One benefit of having a more structured feedback loop, would be that the API developers would have greater awareness of potential errors in the implementation of the API. Another ambition which was mentioned, was to bring scientific theories and best practices from academia into consideration when developing the API. This would aim to complement the current strategy which is largely based around the expertise and experiences of the API architects. Based on these factors and clearly expressed ambitions, we conclude that the law of feedback system is true for APIs. 

\subsubsection{Summary}

\noindent
\textbf{A majority of the laws apply  } %Reviewed by JW
Evidence was found for the laws of Continuing Change, Self Regulation, Conservation of Familiarity, Continuing Growth and Feedback System to establish that they apply to APIs. The most prominent explanation for this is that a large part of the introduced changes were related to functionality. It is especially interesting to note that the laws of Self Regulation and Conservation of Familiarity accurately match the API explored in this paper. 

\smallskip \noindent
\textbf{Two laws apply to a certain extent  } %Reviewed by JW
The laws of Increasing Complexity and Declining Quality were found to apply to APIs, but the extent to which they apply might not be as significant for APIs compared to other types of systems. The reason that this doubt exists is because these motives were secondary to the motives of increased functionality. An alternative explanation for these laws being of lesser significance in APIs could be that the general inertia to modify APIs which exists \cite{google_talk} \cite{henning2007api} \cite{mcdonnell2013empirical} \cite{robbes2012developers} might dominate the need to improve simplicity and quality. 

\smallskip \noindent
\textbf{One law is not applicable  } %Reviewed by JW
Strong evidence was found to suggest that the law of Conservation of Organisational Stability does not apply to APIs. Our results not only show that the law is not true for APIs, but that the opposite of what the law states is true for APIs. This is supported by the consensus in literature of the negative effects caused by modifications to APIs \cite{google_talk} \cite{henning2007api} \cite{mcdonnell2013empirical} \cite{robbes2012developers}. The results from our study also revealed that reluctance to change APIs causes the releases of new versions to be few and sporadic. 

\smallskip \noindent
\textbf{The importance of a Feedback System  } %Reviewed by JW
Especially interesting results were found in regards to the law of Feedback System. The importance of having a structured and developed feedback loop was stressed during the interview and it was also expressed as one of the main points of improvement. This suggests that including feedback from more sources and using this feedback to improve the evolution process should be a consideration for APIs. 


\section{Discussion} \label{discussion}
Our results have provided valuable insight into the motives behind the evolution of APIs. The results show that APIs definitely can be studied from the point of view of long-established software evolution theories. Based on the results, we have formulated the subsequent outcomes. 

\subsection{Discussion RQ1}  




\subsection{Discussion RQ2}



\subsection{Discussion RQ3}







\section{Conclusion} \label{conclusion}
ATTN: This section has not been started. 

1. Small intro which: Summarises the findings of the discussion

2. Conclusions/outcomes:
Industry
Have a more structured feedback loop (include users) this can be future work too
              Greater emphasis should be placed upon communicating with the end users / application developers. They should probably improve their feedback system to get more feedback from the API users.
              Include more scientific theories
              --> consider ecosystem stuff

Academia
Some laws dont apply. Propose a new version of the law.
Interesting that hardware did not drive change. This is cool cuz it means hardware apis can be generalised to any type of api.
Since motives are reverse engineerable, it hsould encourage more ppl to do similar studies
%%William add conclusion ideas here
That the part about controlling how the API users use the API was such an important thing is interesting. (Not something we expected). 
       MAke a study which looks the quality of applications before and after api changes have been introduced

3. Future work: Summarise what the next steps could be.
Obvious benefit for Axis is that the more features == more applications == higher value for their camera. If they have many applications being developed by partners (In part due to the fact they have added more features to the camera API) then the value of their hardware and software will increase. This is probably the case for many other APIs but would need to be studied in some detail to determine the truth behind the statement.
       -->Suggest a similar study which looks at business factors
 in-depth study on each of the laws (more exhaustive) (suggested by Imed during Friday review)

Random tips n trickz:
       Look up the papers from the conference (especially regarding the discussion/conclusion)
       discussion = revisiting research questions (and maybe structuring around industry/academia)
       conclusion = summary part, main final points and future work 
       look up implications for practitioners 
       recommendations for the case company (need to put this somewhere)





\section{Acknowledgements}
We would like to thank Axis and that project at GU. 

\bibliographystyle{abbrv}
\bibliography{bib} 






\end{document}





















% \subsection{RQ1 Results} \label{results_rq1} %Reviewed by JW
% \noindent
% RQ1: \textbf{How do companies actively drive API evolution?}

% \noindent
% RQ2: \textbf{To what extent can we reverse engineer API change decisions?}
% \smallskip

% Many changes were found between version 1.4 and version 2.0. The initial inspection revealed there to be many deprecations which were later re-implemented as new modules. We have group these changes into a single change instead of a deprecation and a re-implementation. In total, thirteen unique changes were found. These changes are shown in Table \ref{table:categories}.

% The changes have been divided up into four specific categories, namely: \textit{new}, \textit{modified}, \textit{removed} and \textit{general trends}. The category \textit{new} concerns additions of modules, \textit{modified} concerns modifications to modules that existed in version 1.4 and \textit{removed} are changes where functionality was removed being deprecated or replaced by functionality. \textit{General trends} are broad changes that are mainly related to design. 

% After cross-examining our results with the interviewee and their responses, we found that 78\% of our main category predictions matched the actual motive of the changes and that 78\% of our secondary categorisations matched the actual motives. 


% \begin{table}
%        \centering
%        \begin{tabular}[ht]{c !{\vrule width 1.5pt} c|c !{\vrule width 1.5pt} c|c} 
%               \toprule

%               \multirow{2}{*}{\textbf{Change}}          & \multicolumn{2}{c !{\vrule width 1.5pt} }{\textbf{Main}}       & \multicolumn{2}{c}{\textbf{Sub}}        \\ \cline{2-5}

%                                    & \textbf{P}                & \textbf{A}                & \textbf{P}                & \textbf{A}         \\ \Xhline{2\arrayrulewidth}
%               axptz                & E                         & E                         & N/A                       & N/A                \\ \hline
%               axaudio              & E                         & E                         & N/A                       & N/A                \\ \hline
%               axstorage            & E                         & E                         & N/A                       & N/A                \\ \hline
%               axserialport         & E                         & E                         & N/A                       & N/A                \\ \hline
%               axevent              & E                         & E                         & G                         & G                  \\ \hline
%               axhttp               & E                         & E                         & G                         & G                  \\ \hline
%               ax\_parameter        & E                         & E                         & G                         & G                  \\ \hline
%               Burst Mode           & R\textsubscript{d}        & R\textsubscript{d}        & N/A                       & N/A                \\ \hline
%               Example Code         & U                         & R\textsubscript{f}        & R\textsubscript{f}        & U                  \\ \hline
%               Documentation        & U                         & U                         & R\textsubscript{f}        & R\textsubscript{f} \\ \hline
%               Interfaces           & G                         & P                         & P                         & G                  \\ \hline
%               3rd Party            & A                         & A                         & N/A                       & N/A                \\ \hline
%               Error Handling       & P                         & P                         & G                         & G                  \\ 

%               \bottomrule
%        \end{tabular}
%        \caption{Categorisation of Changes }
%        \label{table:categories}
% \end{table}



% \subsubsection{axptz} %Reviewed by JW
% The Pan, Tilt and Zoom (ptz) module concerns functionality related to manoeuvring the camera, both mechanically and digitally. We concluded that this change was enhancive, because it is a new feature of the API. There was no secondary motive behind this change, as the change was purely enhancive. The interviewee described how this change, as well as the other changes classified as additions, were all included in the new API at the request of API users. Prior to the change being introduced, there was no API functionality for controlling the camera and as such, it was a high priority addition to the new API. The interviewees' comments allowed us to conclude that we had correctly identified the change as being enhancive. Furthermore, we were also correct in our prediction that there was no secondary change category. 

% \subsubsection{axaudio} %Reviewed by JW
% The most important functionality of the camera is to capture and analyse video data, however, some API users require the ability to analyse audio data. The addition of axaudio allows API users to perform audio analysis of audio streams captured by cameras. This change was determined to be enhancive, as it was an addition of a new feature to the API. We found no secondary motive for the change. Audio analysis had previously not been supported in version 1.4 of the API. However, during the interview, it was revealed that an API user had managed to implement their own audio analysis application using version 1.4 of the API. Given the apparent demand for audio analysis, it was included in version 2.0 of the API.Taking into account the interviewee's reasoning, we concluded that we had successfully determined that the change was enhancive. The addition of axaudio had no secondary motive. 

% \subsubsection{axstorage} %Reviewed by JW
% Prior to the newest version of the API being released, the sole alternative for storing data was to use the Video Management System. Version 2.0 added the possibility of alternative storage solutions, by allowing the camera to interface with external storage devices, such as SD cards. Enhancive was chosen to be the primary category of change, given that axstorage was a new addition to version 2.0. No secondary motive was identified. The interviewee described how limited storage options for the cameras, in version 1.4, was the reason that increased functionality was strongly requested by API users. As such, axstorage was included in version 2.0 of the API.The information gathered from the interview therefore supported our original categorisation; it was an enhancive change. No secondary category was established. 

% \subsubsection{axserialport} %Reviewed by JW
% The addition of axserialport allows API users to connect various devices to the cameras through the use of a serial port. This allows users to integrate multiple devices to create their own unique solutions. This was not possible in version 1.4 of the API. The addition of this module was determined to be an enhancive change, as it involved the addition of a new feature. No relevant secondary category was identified. The addition of axserialport was requested by API users to allow them to connect the cameras to other devices. A possible use case, that was given during the interview, involved a ticketing system which allows for joint analysis of data from multiple devices. As such, it was included in version 2.0, to meet the demand of the API users. Given this information, we concluded that we were correct in categorising this change as enhancive. The categorisation of the secondary category was also correct. 

% \subsubsection{axevent} %Reviewed by JW
% Version 2.0 of the API was designed to be an event-driven system that makes use of callbacks. To achieve this, the old event system had to be re-designed. The new design is used by all features of version 2.0 of the API. An example of when an event would be generated, is when the camera detects movement.  Given that this module was a re-implementation of the previous event system, we concluded that it should be categorised mainly as an enhancive change with the secondary change as groomative. Groomative was chosen as the secondary category due to the additional motive of bringing the new functionality into line with the new design. The interviewee outlined that the previous version of axevent, event, was deprecated in favour of a re-implementation of the new event system. One reason was that the case company was dissatisfied with certain usability aspects of API version 1.4. The module was then completely re-implemented and re-designed according to the new system design of version 2.0. From the discussion in the interview, it was clear that both of our categorisations were correct. The change was primarily enhancive and secondarily groomative.

% \subsubsection{axhttp} %Reviewed by JW
% The module axhttp serves to provide a Common Gateway Interface which allows the camera to dynamically send data to web pages. The previous version of axhttp was re-implemented in version 2.0, to correspond with the new design standards, and at the same time, additional functionality was added to the module. This change re-implemented an existing module while adhering to the new design of API version 2.0. The main categorisation therefore was chosen to be enhancive with groomative as the secondary category. The interviewee described that the main driving force behind this change was to re-implement and add new functionality to the axhttp module, within the standards of the new design.  Our categorisation of enhancive and groomative was therefore correct for this change. The primary intent was to add functionality while also allowing the re-implementation to make use of the new API design. 

% \subsubsection{ax\_parameter} %Reviewed by JW
% The parameter setting module of the API allowed data and application settings to be saved so that they are not lost if the device is not running. This module was re-implemented as ax\_parameter with added functionality and conformance to the new design standards of API version 2.0. Given that this change re-implemented an existing module while also incorporating the new design standards, it has been categorised as being primarily enhancive with a secondary category of groomative. The interviewee clarified that this change was mainly concerned with re-implementing existing functionality, while simultaneously adopting the new standards of version 2.0.  Given the information from the interview, we concluded that this change was correctly categorised; the primary intent was enhancive and the secondary intent was groomative.


% \subsubsection{Burst Mode} %Reviewed by JW
% The burst mode feature of the API allowed users to buffer a series of images for greater analysis. This feature was deprecated during the transition between version 1.4 and 2.0 and was not re-implemented. This change presented itself as a clear example of reductive maintenance, as it was simply removed and without being replaced. We therefore gave no secondary categorisation for this change. The interviewee described, that in order to continue using this feature, it would have to be re-implemented. An impact assessment was undertaken to determine if the removal of the function would be costly. Ultimately, the negative effects were not deemed significant enough and thus the function was removed of the API. We can therefore conclude that we correctly categorised this change as reductive and that there are indeed, no secondary categories to describe this change.


% \subsubsection{Example Code} %Reviewed by JW
% The case company included a selection of example programs to assist developers with creating applications. This trend continued in version 2.0, but there were some significant improvements. The number of example programs and the amount of comments accompanying the code increased, thus improving quality of the examples. We therefore concluded that this change was updative, as the example code was updated according to the new API and the new techniques that it utilises. We further decided that this change also had a secondary category of reformative. During the interview, it became clear that the improvement of the example code was an important change between the two versions. The interviewee described how the examples were used frequently by their customers, however, the old examples had many varied implementation techniques, even for similar tasks. This ultimately meant that the old examples were not satisfactory and that new examples would have to be written, preferably conforming to the same standards. The new example code explicitly covered the new functionality, focusing on new features and showing how they can be combined to create applications. With this information, we concluded that our categorisation was incorrect. It became clear that this change was, in actual fact, primarily reformative. It was also clear that the subcategory should therefore have been updative. 

% \subsubsection{Documentation} %Reviewed by JW
% As the API code was updated in version 2.0, the API documentation was updated to correspond with the new code. While there were no substantial changes, we found that the documentation is no longer offered as a PDF but is instead only offered as HTML.  We categorised this change as being updative with a reformative secondary category for the reasons that the change only updated the documentation to reflect the recent changes in version 2.0. This sentiment was shared by the interviewee; the documentation was only changed according to the current workings of the API and how the new modules interact with each other. We can therefore say that our categorisations were correct, the change was updative and reformative.

% \subsubsection{Interfaces} %Reviewed by JW
% Version 1.4 of the API allowed direct access to the headers of each module available in the API. Version 2.0 changed this by including interfaces through which functionality is accessed. This design change has had an effect on the whole API, as it has changed the structure of modules, but not the functionality of them.We therefore concluded that this change would be best categorised as  groomative. The secondary category was categorised as preventive, as the change could be seen as an attempt to reduce future maintenance. The interview provided further insight into the reasoning behind this design change. Improvements to coding standards, the desire for an event driven system and difficulty in using the existing APIs were all contributors to the decision to use interfaces in versions 2.0 of the API. Furthermore, the re-design would hopefully avoid future maintenance, while also allowing the system to be easily extended. Taking this information into account, we concluded that our categorisation was incorrect. The interview showed that the primary categorisation should have been preventive, given the strong emphasis on avoiding future maintenance and improving usability. We further concluded that the secondary change should have been groomative, to better reflect the intent of improving the APIs maintainability.

% \subsubsection{3\textsuperscript{rd} Party}
% %% REMEMBER TO PROVIDE LINK TO GLIB:::: - https://developer.gnome.org/glib/
% ATTN: (!!!We are waiting for more information from Johanna to confirm / add to this section!!!)
% %%Describe the change 
% 2.0 utilises more 3rd party libraries
% axsound, for example, uses alsa
% All modules use glib
% The advent of the new API saw the inclusion of new 3\textsuperscript{rd} party libraries. For example, axsound utilises a library called Alsa, all interfaces use Glib and daemons have been provided for using D-Bus. These changes potentially make the library much more flexible both for the API designers in terms of features they can provide and for the application developers in terms of applications they can develop.
% We therefore gave this change the main categorisation of adaptive with no suitable sub-categories being found.
% The architects creating the API decided they wished to use Glib which came about primarily from internal discussions at the company.
% %%Relate it to Categories
% Architects decided to use glib, part of an internal decision. 
% Glib (!!!ref to website) was therefore introduced to the new API to help alleviate this 
% The new API utilises Glib in the majority of its interfaces and considering the fact that Glib has its own type of error handling, it seemed sensible to implement the same technique into the new API. However, it was expressed to us that the error handling would have changed between versions regardless of whether or not Glib was included. (!!!This is also too assume-y)

% \subsubsection{Error Handling} %Reviewed by JW
% A substantial change included in version 2.0 was the addition of header files, containing enums of error codes. While it was not evident how the error handling was implemented prior to version 2.0, we concluded that it had changed, given the addition of the new header files. We therefore categorised this change as being primarily preventive, as error handling is preventive by nature. Groomative was decided as the secondary category of maintenance, as improvement of error handling could be regarded as an attempt to improve maintainability.  During the interview, it was made clear that the previous error handling was lacking in expressiveness and usability. Glib was added to version 2.0 and the error handling functionality that Glib provides was incorporated into the new API design. We therefore concluded that our categorisation for this change was correct. The primary reason for the change was to improve the existing error handling while conforming to the new API standard. 

